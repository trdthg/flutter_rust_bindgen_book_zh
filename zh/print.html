<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>flutter_rust_bridge</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">介绍</a></li><li class="chapter-item expanded affix "><li class="part-title">Part I: 核心</li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">1.</strong> 🧭 快速开始</a></li><li class="chapter-item expanded "><a href="tutorial_with_flutter.html"><strong aria-hidden="true">2.</strong> 📚 教程：一个 Flutter 和 Rust 构建的 app</a></li><li class="chapter-item expanded "><a href="feature.html"><strong aria-hidden="true">3.</strong> 🎼 特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="feature/lang.html"><strong aria-hidden="true">3.1.</strong> 语言转换</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="feature/lang_simple.html"><strong aria-hidden="true">3.1.1.</strong> 对应关系总览</a></li><li class="chapter-item expanded "><a href="feature/lang_vec.html"><strong aria-hidden="true">3.1.2.</strong> Vec 和 数组</a></li><li class="chapter-item expanded "><a href="feature/lang_struct.html"><strong aria-hidden="true">3.1.3.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="feature/lang_enum.html"><strong aria-hidden="true">3.1.4.</strong> 枚举</a></li><li class="chapter-item expanded "><a href="feature/lang_external.html"><strong aria-hidden="true">3.1.5.</strong> 外部类型</a></li><li class="chapter-item expanded "><a href="feature/lang_option.html"><strong aria-hidden="true">3.1.6.</strong> Option</a></li><li class="chapter-item expanded "><a href="feature/lang_methods.html"><strong aria-hidden="true">3.1.7.</strong> 方法</a></li><li class="chapter-item expanded "><a href="feature/lang_return_types.html"><strong aria-hidden="true">3.1.8.</strong> 返回值类型</a></li></ol></li><li class="chapter-item expanded "><a href="feature/zero_copy.html"><strong aria-hidden="true">3.2.</strong> 零拷贝</a></li><li class="chapter-item expanded "><a href="feature/stream.html"><strong aria-hidden="true">3.3.</strong> 流 / 迭代器</a></li><li class="chapter-item expanded "><a href="feature/async_dart.html"><strong aria-hidden="true">3.4.</strong> Dart 异步</a></li><li class="chapter-item expanded "><a href="feature/sync_dart.html"><strong aria-hidden="true">3.5.</strong> Dart 同步</a></li><li class="chapter-item expanded "><a href="feature/concurrency.html"><strong aria-hidden="true">3.6.</strong> 并发</a></li><li class="chapter-item expanded "><a href="feature/handler.html"><strong aria-hidden="true">3.7.</strong> Handler</a></li><li class="chapter-item expanded "><a href="feature/init.html"><strong aria-hidden="true">3.8.</strong> 初始化</a></li><li class="chapter-item expanded "><a href="feature/async_rust.html"><strong aria-hidden="true">3.9.</strong> Rust 异步</a></li><li class="chapter-item expanded "><a href="feature/multiple_files.html"><strong aria-hidden="true">3.10.</strong> 多文件</a></li><li class="chapter-item expanded "><a href="feature/build_rs.html"><strong aria-hidden="true">3.11.</strong> 在 build.rs 中运行</a></li><li class="chapter-item expanded "><a href="feature/cancelable_task.html"><strong aria-hidden="true">3.12.</strong> 可取消的任务</a></li><li class="chapter-item expanded "><a href="feature/object_pool.html"><strong aria-hidden="true">3.13.</strong> 对象池</a></li><li class="chapter-item expanded "><a href="feature/misc.html"><strong aria-hidden="true">3.14.</strong> 杂项</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Part II: 用户指南</li><li class="chapter-item expanded "><a href="template.html"><strong aria-hidden="true">4.</strong> 从模板创建</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="template/setup.html"><strong aria-hidden="true">4.1.</strong> 创建一个新项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="template/setup_android.html"><strong aria-hidden="true">4.1.1.</strong> 安卓设置</a></li><li class="chapter-item expanded "><a href="template/setup_ios.html"><strong aria-hidden="true">4.1.2.</strong> IOS 设置</a></li><li class="chapter-item expanded "><a href="template/setup_web.html"><strong aria-hidden="true">4.1.3.</strong> Web 设置</a></li><li class="chapter-item expanded "><a href="template/setup_desktop.html"><strong aria-hidden="true">4.1.4.</strong> Windows 和 Linux</a></li><li class="chapter-item expanded "><a href="template/setup_others.html"><strong aria-hidden="true">4.1.5.</strong> 其他平台</a></li></ol></li><li class="chapter-item expanded "><a href="template/tour.html"><strong aria-hidden="true">4.2.</strong> 模板之旅</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="template/tour_api.html"><strong aria-hidden="true">4.2.1.</strong> native/src/api.rs</a></li><li class="chapter-item expanded "><a href="template/tour_gradle.html"><strong aria-hidden="true">4.2.2.</strong> android/app/build.gradle</a></li><li class="chapter-item expanded "><a href="template/tour_native_proj.html"><strong aria-hidden="true">4.2.3.</strong> native/native.xcodeproj</a></li><li class="chapter-item expanded "><a href="template/tour_justfile.html"><strong aria-hidden="true">4.2.4.</strong> justfile</a></li><li class="chapter-item expanded "><a href="template/tour_cmake.html"><strong aria-hidden="true">4.2.5.</strong> rust.cmake</a></li></ol></li><li class="chapter-item expanded "><a href="template/generate.html"><strong aria-hidden="true">4.3.</strong> 代码生成</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="template/generate_install.html"><strong aria-hidden="true">4.3.1.</strong> 安装 codegen</a></li><li class="chapter-item expanded "><a href="template/generate_adding_code.html"><strong aria-hidden="true">4.3.2.</strong> 添加代码</a></li><li class="chapter-item expanded "><a href="template/generate_build_runner.html"><strong aria-hidden="true">4.3.3.</strong> 使用 build_runner</a></li><li class="chapter-item expanded "><a href="template/generate_finish.html"><strong aria-hidden="true">4.3.4.</strong> 收尾工作</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="integrate.html"><strong aria-hidden="true">5.</strong> 集成到现有项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrate/new_crate.html"><strong aria-hidden="true">5.1.</strong> 创建一个新 crate</a></li><li class="chapter-item expanded "><a href="integrate/deps.html"><strong aria-hidden="true">5.2.</strong> 安装依赖</a></li><li class="chapter-item expanded "><a href="integrate/android.html"><strong aria-hidden="true">5.3.</strong> 与 Android 集成</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrate/android_tasks.html"><strong aria-hidden="true">5.3.1.</strong> Hooking onto tasks</a></li><li class="chapter-item expanded "><a href="integrate/android_cmake.html"><strong aria-hidden="true">5.3.2.</strong> 在 Gradle 中使用 CMake</a></li></ol></li><li class="chapter-item expanded "><a href="integrate/ios.html"><strong aria-hidden="true">5.4.</strong> 与 iOS/MacOS 集成</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrate/ios_proj.html"><strong aria-hidden="true">5.4.1.</strong> 创建 Rust 项目</a></li><li class="chapter-item expanded "><a href="integrate/ios_linking.html"><strong aria-hidden="true">5.4.2.</strong> 链接该项目</a></li><li class="chapter-item expanded "><a href="integrate/ios_gen.html"><strong aria-hidden="true">5.4.3.</strong> 生成代码绑定</a></li><li class="chapter-item expanded "><a href="integrate/ios_headers.html"><strong aria-hidden="true">5.4.4.</strong> 使用假头文件</a></li></ol></li><li class="chapter-item expanded "><a href="integrate/desktop.html"><strong aria-hidden="true">5.5.</strong> 与 Windows and Linux 集成</a></li><li class="chapter-item expanded "><a href="integrate/web.html"><strong aria-hidden="true">5.6.</strong> 与 Web 集成</a></li><li class="chapter-item expanded "><a href="integrate/usage.html"><strong aria-hidden="true">5.7.</strong> 使用动态连接库</a></li><li class="chapter-item expanded "><a href="integrate/finish.html"><strong aria-hidden="true">5.8.</strong> 收尾工作</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Part III: 贡献指南</li><li class="chapter-item expanded "><a href="contributing/overview.html"><strong aria-hidden="true">6.</strong> 总览</a></li><li class="chapter-item expanded "><a href="contributing/design.html"><strong aria-hidden="true">7.</strong> 整体设计</a></li><li class="chapter-item expanded "><a href="contributing/appendix.html"><strong aria-hidden="true">8.</strong> 附录</a></li><li class="chapter-item expanded affix "><li class="part-title">Part IV: 更多文档</li><li class="chapter-item expanded "><a href="tutorial_pure_dart.html"><strong aria-hidden="true">9.</strong> 教程：Pure Dart</a></li><li class="chapter-item expanded "><a href="safety.html"><strong aria-hidden="true">10.</strong> 安全问题</a></li><li class="chapter-item expanded "><a href="troubleshooting.html"><strong aria-hidden="true">11.</strong> 疑难解答</a></li><li class="chapter-item expanded "><a href="command_line.html"><strong aria-hidden="true">12.</strong> 命令行参数</a></li><li class="chapter-item expanded "><a href="set_up_from_scratch.html"><strong aria-hidden="true">13.</strong> 从零开始设置 Fluuter/Rust 环境</a></li><li class="chapter-item expanded "><a href="article.html"><strong aria-hidden="true">14.</strong> 文章</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="article/async_in_rust.html"><strong aria-hidden="true">14.1.</strong> Rust 异步</a></li><li class="chapter-item expanded "><a href="article/generate_multiple_files.html"><strong aria-hidden="true">14.2.</strong> 生成多文件</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">flutter_rust_bridge</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="flutter_rust_bridge-用于-flutter-和-rust-的高级内存安全绑定生成器"><a class="header" href="#flutter_rust_bridge-用于-flutter-和-rust-的高级内存安全绑定生成器"><a href="https://github.com/fzyzcjy/flutter_rust_bridge">flutter_rust_bridge</a>: 用于 Flutter 和 Rust 的高级内存安全绑定生成器</a></h1>
<p><em>High-level memory-safe binding generator for Flutter/Dart &lt;-&gt; Rust</em></p>
<p><a href="https://crates.io/crates/flutter_rust_bridge"><img src="https://img.shields.io/crates/v/flutter_rust_bridge.svg" alt="Rust Package" /></a>
<a href="https://pub.dev/packages/flutter_rust_bridge"><img src="https://img.shields.io/pub/v/flutter_rust_bridge.svg" alt="Flutter Package" /></a>
<a href="https://github.com/fzyzcjy/flutter_rust_bridge"><img src="https://img.shields.io/github/stars/fzyzcjy/flutter_rust_bridge" alt="Stars" /></a>
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/actions/workflows/ci.yaml"><img src="https://github.com/fzyzcjy/flutter_rust_bridge/actions/workflows/ci.yaml/badge.svg" alt="CI" /></a>
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/actions/workflows/post_release.yaml"><img src="https://github.com/fzyzcjy/flutter_rust_bridge/actions/workflows/post_release.yaml/badge.svg" alt="Example" /></a>
<a href="https://app.codacy.com/gh/fzyzcjy/flutter_rust_bridge?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=fzyzcjy/flutter_rust_bridge&amp;utm_campaign=Badge_Grade_Settings"><img src="https://api.codacy.com/project/badge/Grade/6afbdad19e7245adbf9e9771777be3d7" alt="Codacy Badge" /></a></p>
<p><img src="https://github.com/fzyzcjy/flutter_rust_bridge/raw/master/book/logo.png" alt="Logo" /></p>
<p>想把 <a href="https://flutter.dev/">Flutter</a>（一个跨平台的热重载快速开发 UI 工具包）和
<a href="https://www.rust-lang.org/">Rust</a>（一种使每个人都能构建可靠和高效软件的语言）的优点结合起来？它来了！</p>
<h2 id="-优势"><a class="header" href="#-优势">🚀 优势</a></h2>
<ul>
<li><strong>内存安全</strong>: 完全不用考虑 malloc 和 free.</li>
<li><strong>特性丰富</strong>:支持类似 Rust 的枚举，根据平台自动优化的 <code>Vec</code>, 可以递归的 <code>struct</code>, 大数组零拷贝，<code>流数据</code> (迭代器)
抽象，错误处理 (<code>Result</code>), 可取消的任务，并发控制，等。在
<a href="https://fzyzcjy.github.io/flutter_rust_bridge/feature.html">这里</a> 查看所有特性。</li>
<li><strong>异步支持</strong>: Rust 代码永远不会阻塞 Flutter. 在 Flutter 的主隔离区 <code>main isolate (或者说 thread)</code>
中自然的调用 Rust 代码。</li>
<li><strong>轻量级</strong>: 这不是一个全面的框架，你可以自由的使用你喜欢的 Flutter 和 Rust 第三方库。<sub>例如，使用 Flutter 库（比如
MobX）进行状态管理更加优雅简单（相比于在 Rust 中实现）; 使用 Rust 实现一个照片处理的算法更加快速和安全 (相比于在 Flutter
中实现).</sub></li>
<li><strong>跨平台</strong>: 支持 Android, iOS, Windows, Linux, MacOS
(<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/315">Web</a> coming soon)</li>
<li><strong>方便 &amp; 易于代码审查</strong>: 这个库只是简单地模拟了人类编写的模板代码，一点也不神奇！如果你想让说服你自己（或你的团队）相信它是安全的，
没有多少代码可看。 (<a href="https://fzyzcjy.github.io/flutter_rust_bridge/safety.html">更多</a>
safety concerns.)</li>
<li><strong>快速</strong>: 这个库只做了一个浅层次的包装（尽管功能丰富），没有 pritobuf 序列化的开销，因此高性能。(更多的
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/318#issuecomment-1034536815">benchmarks</a>
即将到来) <small>(扔掉了像线程池这样的组件，使它更快)</small></li>
<li><strong>与纯 Dart 兼容:</strong> 尽管名字里包含了 Rust，这个库 100% 兼容
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/README.md">Pure Dart</a></li>
</ul>
<h2 id="-用户指南"><a class="header" href="#-用户指南">💡 用户指南</a></h2>
<p>请看 <a href="https://fzyzcjy.github.io/flutter_rust_bridge/">用户指南</a> for
<a href="https://fzyzcjy.github.io/flutter_rust_bridge/quickstart.html">show-me-the-code</a>,
<a href="https://fzyzcjy.github.io/flutter_rust_bridge/tutorial_with_flutter.html">教程</a>,
<a href="https://fzyzcjy.github.io/flutter_rust_bridge/feature.html">特性</a> and much more.</p>
<h2 id="-ps-方便的-flutter-测试"><a class="header" href="#-ps-方便的-flutter-测试">📎 P.S. 方便的 Flutter 测试</a></h2>
<p>如果您想在 Flutter
中方便地编写和调试测试，行为历史、时间回溯、屏幕截图、快速重新执行、视频录制、互动模式等功能，这里有我的另一个开源库：<a href="https://github.com/fzyzcjy/flutter_convenient_test">flutter_convenient_test</a>.</p>
<h2 id="-贡献者"><a class="header" href="#-贡献者">✨ 贡献者</a></h2>
<!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section -->
<p><a href="index.html#contributors-"><img src="https://img.shields.io/badge/all_contributors-29-orange.svg?style=flat-square" alt="All Contributors" /></a></p>
<!-- ALL-CONTRIBUTORS-BADGE:END -->
<p>Thanks goes to these wonderful people
(<a href="https://allcontributors.org/docs/en/emoji-key">emoji key</a> following
<a href="https://github.com/all-contributors/all-contributors">all-contributors</a>
specification):</p>
<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tr>
    <td align="center"><a href="https://github.com/fzyzcjy"><img src="https://avatars.githubusercontent.com/u/5236035?v=4?s=100" width="100px;" alt=""/><br /><sub><b>fzyzcjy</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=fzyzcjy" title="Code">💻</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=fzyzcjy" title="Documentation">📖</a> <a href="index.html#example-fzyzcjy" title="Examples">💡</a> <a href="index.html#ideas-fzyzcjy" title="Ideas, Planning, & Feedback">🤔</a> <a href="index.html#maintenance-fzyzcjy" title="Maintenance">🚧</a></td>
    <td align="center"><a href="https://github.com/Desdaemon"><img src="https://avatars.githubusercontent.com/u/36768030?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Viet Dinh</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Desdaemon" title="Code">💻</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Desdaemon" title="Tests">⚠️</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Desdaemon" title="Documentation">📖</a></td>
    <td align="center"><a href="https://github.com/SecondFlight"><img src="https://avatars.githubusercontent.com/u/6700184?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Joshua Wade</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=SecondFlight" title="Code">💻</a></td>
    <td align="center"><a href="https://github.com/smw-wagnerma"><img src="https://avatars.githubusercontent.com/u/66412697?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Marcel</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=smw-wagnerma" title="Code">💻</a></td>
    <td align="center"><a href="https://github.com/rustui"><img src="https://avatars.githubusercontent.com/u/90625190?v=4?s=100" width="100px;" alt=""/><br /><sub><b>rustui</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=rustui" title="Documentation">📖</a></td>
    <td align="center"><a href="https://adventures.michaelfbryan.com/"><img src="https://avatars.githubusercontent.com/u/17380079?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Michael Bryan</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Michael-F-Bryan" title="Code">💻</a></td>
    <td align="center"><a href="https://bus710.net"><img src="https://avatars.githubusercontent.com/u/8920680?v=4?s=100" width="100px;" alt=""/><br /><sub><b>bus710</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=bus710" title="Documentation">📖</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://scholar.google.com/citations?user=RbAto7EAAAAJ"><img src="https://avatars.githubusercontent.com/u/1213857?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Sebastian Urban</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=surban" title="Code">💻</a></td>
    <td align="center"><a href="https://github.com/trobanga"><img src="https://avatars.githubusercontent.com/u/8888869?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Daniel</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=trobanga" title="Code">💻</a></td>
    <td align="center"><a href="https://github.com/AlienKevin"><img src="https://avatars.githubusercontent.com/u/22850071?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Kevin Li</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=AlienKevin" title="Code">💻</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=AlienKevin" title="Documentation">📖</a></td>
    <td align="center"><a href="https://valeth.me"><img src="https://avatars.githubusercontent.com/u/3198362?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Patrick Auernig</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=valeth" title="Code">💻</a></td>
    <td align="center"><a href="https://antonok.com"><img src="https://avatars.githubusercontent.com/u/22821309?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Anton Lazarev</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=antonok-edm" title="Code">💻</a></td>
    <td align="center"><a href="https://github.com/Unoqwy"><img src="https://avatars.githubusercontent.com/u/65187632?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Unoqwy</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Unoqwy" title="Code">💻</a></td>
    <td align="center"><a href="https://feber.dev"><img src="https://avatars.githubusercontent.com/u/1727318?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Febrian Setianto</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=feber" title="Documentation">📖</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/Syndim"><img src="https://avatars.githubusercontent.com/u/835035?v=4?s=100" width="100px;" alt=""/><br /><sub><b>syndim</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=syndim" title="Code">💻</a></td>
    <td align="center"><a href="https://github.com/sagudev"><img src="https://avatars.githubusercontent.com/u/16504129?v=4?s=100" width="100px;" alt=""/><br /><sub><b>sagu</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=sagudev" title="Code">💻</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=sagudev" title="Documentation">📖</a></td>
    <td align="center"><a href="https://bandism.net/"><img src="https://avatars.githubusercontent.com/u/22633385?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Ikko Ashimine</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=eltociear" title="Documentation">📖</a></td>
    <td align="center"><a href="https://github.com/alanlzhang"><img src="https://avatars.githubusercontent.com/u/59032810?v=4?s=100" width="100px;" alt=""/><br /><sub><b>alanlzhang</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=alanlzhang" title="Code">💻</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=alanlzhang" title="Documentation">📖</a></td>
    <td align="center"><a href="https://github.com/sccheruku"><img src="https://avatars.githubusercontent.com/u/5800058?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Sai Chaitanya</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=sccheruku" title="Code">💻</a></td>
    <td align="center"><a href="https://ares.zone (国内)"><img src="https://avatars.githubusercontent.com/u/40336192?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Ares Andrew</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=TENX-S" title="Documentation">📖</a></td>
    <td align="center"><a href="https://github.com/raphaelrobert"><img src="https://avatars.githubusercontent.com/u/9882746?v=4?s=100" width="100px;" alt=""/><br /><sub><b>raphaelrobert</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=raphaelrobert" title="Documentation">📖</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/thomas725"><img src="https://avatars.githubusercontent.com/u/68635351?v=4?s=100" width="100px;" alt=""/><br /><sub><b>thomas725</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=thomas725" title="Documentation">📖</a></td>
    <td align="center"><a href="https://dport.me"><img src="https://avatars.githubusercontent.com/u/7816187?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Daniel Porteous (dport)</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=banool" title="Documentation">📖</a></td>
    <td align="center"><a href="https://github.com/w-ensink"><img src="https://avatars.githubusercontent.com/u/46427708?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Wouter Ensink</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=w-ensink" title="Documentation">📖</a></td>
    <td align="center"><a href="https://github.com/dbsxdbsx"><img src="https://avatars.githubusercontent.com/u/17372655?v=4?s=100" width="100px;" alt=""/><br /><sub><b>老董</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=dbsxdbsx" title="Code">💻</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=dbsxdbsx" title="Documentation">📖</a></td>
    <td align="center"><a href="https://github.com/lattice0"><img src="https://avatars.githubusercontent.com/u/6632321?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Lattice 0</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=lattice0" title="Code">💻</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=lattice0" title="Documentation">📖</a></td>
    <td align="center"><a href="https://soeur.dev"><img src="https://avatars.githubusercontent.com/u/26034975?v=4?s=100" width="100px;" alt=""/><br /><sub><b>orange soeur</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=juzi5201314" title="Documentation">📖</a></td>
    <td align="center"><a href="https://github.com/Roms1383"><img src="https://avatars.githubusercontent.com/u/21016014?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Rom's</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Roms1383" title="Code">💻</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Roms1383" title="Documentation">📖</a></td>
  </tr>
  <tr>
    <td align="center"><a href="https://github.com/Cupnfish"><img src="https://avatars.githubusercontent.com/u/40173605?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Cupnfish</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Cupnfish" title="Code">💻</a></td>
  </tr>
</table>
<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->
<!-- ALL-CONTRIBUTORS-LIST:END -->
<p>More specifically, thanks for all these contributions:</p>
<ul>
<li><a href="https://github.com/Desdaemon">Desdaemon</a>: Support not only simple enums but
also enums with fields which gets translated to native enum or freezed class
in Dart. Support the Option type as nullable types in Dart. Support Vec of
Strings type. Support comments in code. Add marker attributes for future
usage. Add Linux and Windows support for with-flutter example, and make CI
works for that. Avoid parameter collision. Overhaul the documentation and add
several chapters to demonstrate configuring a Flutter+Rust project in all five
platforms. Refactor command module. Precompiled binary CI workflow. Fix bugs.</li>
<li><a href="https://github.com/SecondFlight">SecondFlight</a>: Allow structs and enums to be
imported from other files within the crate by creating source graph.
Auto-create relavent dir. Fix <code>store_dart_post_cobject</code> error with ffigen 6.0.</li>
<li><a href="https://github.com/Unoqwy">Unoqwy</a>: Add struct mirrors, such that types in
the external crates can be imported and used without redefining and copying.</li>
<li><a href="https://github.com/antonok-edm">antonok-edm</a>: Avoid converting syn types to
strings before parsing to improve code and be more robust.</li>
<li><a href="https://github.com/lattice0">lattice0</a>: Support methods, such that Rust
struct impls can be converted to Dart class methods. StreamSink at any
argument.</li>
<li><a href="https://github.com/sagudev">sagudev</a>: Make code generator a <code>lib</code>. Add error
types. Depend on <code>cbindgen</code>. Fix LLVM paths. Update deps. Fix CI errors.</li>
<li><a href="https://github.com/surban">surban</a>: Support unit return type. Skip
unresolvable modules. Ignore prefer_const_constructors. Non-final Dart fields.</li>
<li><a href="https://github.com/trobanga">trobanga</a>: Add support for <code>[T;N]</code> structs. Add
<code>usize</code> support. Add a cmd argument. Separate dart tests.</li>
<li><a href="https://github.com/Roms1383">Roms1383</a>: Fix build_runner calling bug. Remove
global <code>ffigen</code> dependency. Improve version check. Fix enum name-variant
conflicts. Update CI. Code cleanup.</li>
<li><a href="https://github.com/dbsxdbsx">dbsxdbsx</a>: Allow generating multiple Rust and
Dart files.</li>
<li><a href="https://github.com/AlienKevin">AlienKevin</a>: Add flutter example for macOS.
Add doc for Android NDK bug.</li>
<li><a href="https://github.com/alanlzhang">alanlzhang</a>: Add generation for Dart metadata.</li>
<li><a href="https://github.com/efc-mw">efc-mw</a>: Improve Windows encoding handling.</li>
<li><a href="https://github.com/valeth">valeth</a>: Rename callFfi's port.</li>
<li><a href="https://github.com/Cupnfish">Cupnfish</a>: Allow multi mirror.</li>
<li><a href="https://github.com/sccheruku">sccheruku</a>: Prevent double-generating utility.</li>
<li><a href="https://github.com/w-ensink">w-ensink</a>: Improve doc. Fix CI. Refactor. Add
tests.</li>
<li><a href="https://github.com/Michael-F-Bryan">Michael-F-Bryan</a>: Detect broken bindings.</li>
<li><a href="https://github.com/bus710">bus710</a>: Add a case in troubleshooting.</li>
<li><a href="https://github.com/Syndim">Syndim</a>: Add a bracket to box.</li>
<li><a href="https://github.com/banool">banool</a>: Fix symbol-stripping doc.</li>
<li><a href="https://github.com/TENX-S">TENX-S</a>: Improve doc. Reproduce a bug.</li>
<li><a href="https://github.com/raphaelrobert">raphaelrobert</a>: Remove oudated doc.</li>
<li><a href="https://github.com/thomas725">thomas725</a>: Improve doc.</li>
<li><a href="https://github.com/juzi5201314">juzi5201314</a>: Improve doc.</li>
<li><a href="https://github.com/feber">feber</a>: Fix doc link.</li>
<li><a href="https://github.com/rustui">rustui</a>: Fix a typo.</li>
<li><a href="https://github.com/eltociear">eltociear</a>: Fix a typo.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h1>
<p>像平常一样编写你的 Rust 函数和类型定义。</p>
<pre><code class="language-rust ignore">// 一个普通的 Rust 函数 ...
pub fn draw_tree(root: TreeNode, mode: DrawMode) -&gt; Result&lt;Vec&lt;u8&gt;&gt; { /* ... */ }

// ... 和一些丰富的类型
pub struct TreeNode { pub value: String, pub children: Vec&lt;MyTreeNode&gt; }
pub enum DrawMode { Colorful {palette: String}, Grayscale }
</code></pre>
<p>安装代码生成器 <code>flutter_rust_bridge_codegen</code>:</p>
<pre><code class="language-bash">cargo install flutter_rust_bridge_codegen
# 或者使用 cargo-binstall
cargo binstall flutter_rust_bridge_codegen
# 或者使用 scoop (Windows)
scoop bucket add frb https://github.com/Desdaemon/scoop-repo
scoop install flutter_rust_bridge_codegen
# 或者使用 Homebrew
brew install desdaemon/repo/flutter_rust_bridge_codegen
</code></pre>
<p><small>(感谢 @Desdaemon 将脚本发布到 brew/scoop)</small></p>
<p>接着运行代码生成。</p>
<p><small>注意：安装需要一些步骤。你可以查看 <a href="tutorial_with_flutter.html">教程</a>, <a href="template.html">从模板创建项目</a>
或者 <a href="integrate.html">与现有项目集成</a> 等章节获取更多信息.</small></p>
<pre><code class="language-bash">flutter_rust_bridge_codegen --rust-input path/to/api.rs \
                            --dart-output path/to/bridge_generated.dart
</code></pre>
<p>绑定代码生成之后，你可以在 Flutter/Dart 中无缝使用：</p>
<pre><code class="language-dart">api.drawTree(TreeNode(value: &quot;root&quot;, ...), Colorful(palette: &quot;viridis&quot;));
</code></pre>
<blockquote>
<p>译者注：如果你在代码生成时遇到了这个错误 <code>fatal error: 'stdbool.h' file not found</code>
可以尝试阅读：<a href="https://github.com/dart-lang/ffigen/issues/257#issuecomment-1061788936">dart-lang/ffigen/issues/257</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="教程一个-flutter-和-rust-构建的-app"><a class="header" href="#教程一个-flutter-和-rust-构建的-app">教程：一个 Flutter 和 Rust 构建的 app</a></h1>
<p>在这个教程中，我们将绘制一个
<a href="https://en.wikipedia.org/wiki/Mandelbrot_set">曼德博集合（英语：Mandelbrot set，或译为曼德布洛特复数集合）</a>（一个著名的分形）。这个图片会由
Rust 算法生成，并在 Flutter 中绘制，Rust 和 Flutter 会通过这个库通信。</p>
<!-- markdownlint-disable MD033 -->
<details>
<summary>(点击查看：Mandelbrot set 是什么：)</summary>
<p>曼德博集合是由复数 <code>c</code> 组成的点的集合，对于这些点，均满足函数：
<code>f_c(z) = z^{2} + c</code>，不同的参数可能使序列的绝对值逐渐发散到无限大，也可能收敛在有限的区域内。曼德博集合 M
就是使序列不延伸至无限大的所有复数 c 的集合。曼德勃罗集的图像显示了一个精心设计的、无限复杂的边界
随着放大倍数的增加，逐渐显示出越来越细的递归细节。放大倍数时，显示出越来越细的递归细节。</p>
<p align="center">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Mandelbrot_sequence_new.gif/220px-Mandelbrot_sequence_new.gif">
</p>
<p>图片来源：维基百科</p>
</details>
<h2 id="获取源代码"><a class="header" href="#获取源代码">获取源代码</a></h2>
<p><a href="https://flutter.dev/docs/get-started/install">安装 Flutter</a> (如果你想把程序运行在桌面上，可以选择添加
<a href="https://flutter.dev/desktop">桌面支持</a>),
<a href="https://www.rust-lang.org/learn/get-started">安装 Rust</a>, 接着克隆样例代码：</p>
<pre><code class="language-shell">git clone https://github.com/fzyzcjy/flutter_rust_bridge &amp;&amp; cd flutter_rust_bridge/frb_example/with_flutter
</code></pre>
<h2 id="可选运行代码生成器"><a class="header" href="#可选运行代码生成器">可选：运行代码生成器</a></h2>
<p>这一步是可选的，因为我已经在 <a href="./quickstart.html">快速入门</a> 时生成了绑定代码，再次运行也不会产生任何改变。</p>
<p>一旦你修改了 <code>api.rs</code>，就需要再次运行代码生成。代码生成器需要的依赖可以在
<a href="integrate/deps.html">Installing dependencies</a> 章节查看</p>
<h2 id="运行-app"><a class="header" href="#运行-app">运行 app</a></h2>
<h3 id="前言命令细节"><a class="header" href="#前言命令细节">前言：命令细节</a></h3>
<p>如果你需要了解命令的具体细节，可以查看
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/workflows/ci.yaml">CI 工作流</a>。<code>flutter_android_test</code>,
<code>flutter_ios_test</code>, <code>flutter_windows_test</code>, <code>flutter_macos_test</code> 和
<code>flutter_linux_test</code> 演示了从一台新机器上运行该项目所需要的所有命令</p>
<blockquote>
<p>译者注：如果您遇到运行失败，缺少环境等问题，请参考上述 CI 工作流。下面的 cargo ndk 等部分工具，和对应的交叉编译环境都需要单独安装，也可以参照
PART II 的项目设置部分。</p>
</blockquote>
<h3 id="android-app"><a class="header" href="#android-app">Android app</a></h3>
<ul>
<li>把 <code>ANDROID_NDK=(path to NDK)</code> 添加到 <code>android/gradle.properties</code></li>
<li>接着运行 <code>cargo ndk -o ../android/app/src/main/jniLibs build</code>.</li>
<li>最后运行 <code>flutter run</code>.</li>
</ul>
<p><strong>注意</strong>: <a href="https://stackoverflow.com/q/69515032/4619958">这个教程</a> 能够帮你在构建 Flutter
程序时自动运行 cargo build.</p>
<h3 id="ios-app"><a class="header" href="#ios-app">iOS app</a></h3>
<ul>
<li>打开 <code>Cargo.toml</code> 并把 <code>cdylib</code> 修改为 <code>staticlib</code></li>
<li>接着运行
<code>cargo lipo &amp;&amp; cp target/universal/debug/libflutter_rust_bridge_example.a ../ios/Runner</code>
编译 Rust 代码，并复制静态连接库。</li>
<li>最后像平时一样运行 <code>flutter run</code>.</li>
</ul>
<p><strong>注意</strong>: <a href="https://stackoverflow.com/q/69515032/4619958">这个教程</a> 能够帮你在构建 Flutter
程序时自动运行 cargo build.</p>
<h3 id="windows-app"><a class="header" href="#windows-app">Windows app</a></h3>
<p>假设 <a href="https://flutter.dev/desktop#set-up">Flutter 桌面支持</a> 已经配置完成，你可以直接运行
<code>flutter run</code>。更多细节可以在
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/66">#66</a>.</p>
<h3 id="linux-app"><a class="header" href="#linux-app">Linux app</a></h3>
<p>和 Windows 一样。如果你是通过 <code>snap</code> 安装的 Flutter, 请阅读一下
<a href="https://github.com/canonical/flutter-snap/issues/53">#53</a>.</p>
<h3 id="macos-app"><a class="header" href="#macos-app">MacOS app</a></h3>
<p>和 Windows 一样。(P.S. 本质上说，<code>cargo-xcode</code> 被用于自动化)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特性"><a class="header" href="#特性">特性</a></h1>
<p>这一章，我们将展示该库的各个特性。请使用左侧/左上的菜单栏切换页面。</p>
<h2 id="序言"><a class="header" href="#序言">序言</a></h2>
<h3 id="这个库是什么"><a class="header" href="#这个库是什么">这个库是什么？</a></h3>
<p>这个库只是一个代码生成器，帮助你的 Flutter / Dart 调用 Rust
函数。它只是生成了一些模板代码，代替了手工编写。此外，我们还为您提供了详细的教程，让您可以尝试实例，创建新的应用程序，并与现有的应用程序集成。</p>
<p>当然了，你仍然需要对 Flutter/Dart，Rust 以及
<a href="https://flutter.dev/docs/development/platform-integration/c-interop">ffi</a>.
有一些基本的了解。</p>
<h3 id="完整实例"><a class="header" href="#完整实例">完整实例</a></h3>
<p>如果你想看一些例子 <small>我要提前警告你，示例代码真的非常多</small>。
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/rust/src/api.rs">pure_dart's api.rs</a>
文件里包含了对该库的所有测试。</p>
<p>此外，当你对基本的例子已经熟悉后，可以看一下
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/frb_example/pure_dart_multi/rust/src">pure_dart_multi</a>
项目，这个例子包含多个 API 模块。对于复杂的项目来说是相当有用的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语言间转换"><a class="header" href="#语言间转换">语言间转换</a></h1>
<p>这一部分我们将展示 Rust 和 Dart 语言间的特性是如何转换。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简单的对应关系"><a class="header" href="#简单的对应关系">简单的对应关系</a></h1>
<p>下面是一个简短的概览，显示了代码生成器可以生成的内容（并非完备）。有些行附带超链接，里面有更详细的解释。</p>
<div class="table-wrapper"><table><thead><tr><th>Rust</th><th>Dart</th></tr></thead><tbody>
<tr><td><a href="feature/lang_vec.html"><code>Vec&lt;u8&gt;</code>, <code>Vec&lt;i8&gt;</code>..</a></td><td><code>Uint8List</code>, <code>Int8List</code>, ..</td></tr>
<tr><td><a href="feature/lang_vec.html"><code>Vec&lt;T&gt;</code></a></td><td><code>List&lt;T&gt;</code></td></tr>
<tr><td><a href="feature/lang_vec.html"><code>[T; N]</code></a></td><td><code>List&lt;T&gt;</code></td></tr>
<tr><td><a href="feature/lang_struct.html"><code>struct { .. }</code>, <code>struct( .. )</code></a></td><td><code>class</code></td></tr>
<tr><td><a href="feature/lang_enum.html"><code>enum { A, B }</code></a></td><td><code>enum</code></td></tr>
<tr><td><a href="feature/lang_enum.html"><code>enum { A(..) }</code></a></td><td><code>@freezed class</code></td></tr>
<tr><td><a href="feature/lang_external.html"><code>use ...</code></a></td><td>act normally</td></tr>
<tr><td><a href="feature/lang_option.html"><code>Option&lt;T&gt;</code></a></td><td><code>T?</code></td></tr>
<tr><td><code>Box&lt;T&gt;</code></td><td><code>T</code></td></tr>
<tr><td>comments</td><td>same</td></tr>
<tr><td><code>Result::Err</code>, panic</td><td><code>throw Exception</code></td></tr>
<tr><td><code>i8</code>, <code>u8</code>, .., <code>usize</code></td><td><code>int</code></td></tr>
<tr><td><code>f32</code>, <code>f64</code></td><td><code>double</code></td></tr>
<tr><td><code>bool</code></td><td><code>bool</code></td></tr>
<tr><td><code>String</code></td><td><code>String</code></td></tr>
<tr><td><code>()</code></td><td><code>void</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="vec-and-数组"><a class="header" href="#vec-and-数组">Vec and 数组</a></h1>
<h2 id="vecu8-veci8-"><a class="header" href="#vecu8-veci8-"><code>Vec&lt;u8&gt;</code>, <code>Vec&lt;i8&gt;</code>, ...</a></h2>
<p>在 Dart 中，当你想表达一个长字节数组，例如大图片或一些二进制 blob，通常会使用 <code>Uint8List</code> 而不是
<code>List&lt;int&gt;</code>，因为前者的性能更好。</p>
<p><code>flutter_rust_bridge</code> 也为你考虑到了这一点。当你使用到 <code>Vec&lt;u8&gt;</code>（或
<code>Vec&lt;i8&gt;</code>，<code>Vec&lt;i32&gt;</code>，等）时，它们会被翻译成 <code>Uint8List</code> 或其它类似的结构。</p>
<h2 id="vect"><a class="header" href="#vect"><code>Vec&lt;T&gt;</code></a></h2>
<p>当你使用 <code>Vec&lt;T&gt;</code>，并且 T 是 <code>u8</code>、<code>i8</code> 等以外的类型时，它会被转换成正常的 <code>List&lt;T&gt;</code>。</p>
<h2 id="t-n"><a class="header" href="#t-n"><code>[T; N]</code></a></h2>
<p>由于 Dart 没有对静态大小的数组进行特殊处理，所以它也会被转换为 <code>List&lt;T&gt;</code>。</p>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<pre><code class="language-rust noplayground">pub fn draw_tree(tree: Vec&lt;TreeNode&gt;) -&gt; Vec&lt;u8&gt; { ... }
</code></pre>
<p>转换为：</p>
<pre><code class="language-Dart">Future&lt;Uint8List&gt; drawTree({required List&lt;TreeNode&gt; tree});
</code></pre>
<p>注意：如果你对 <code>Future</code> 感兴趣，请看 <a href="feature/async_dart.html">这里</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<p>一般的 Rust 结构体都是支持的，你甚至能够使用递归字段，比如：</p>
<pre><code class="language-rust noplayground">pub struct TreeNode {
    pub value: String,
    pub children: Vec&lt;MyTreeNode&gt;,
    pub parent: Box&lt;MyTreeNode&gt;
}
</code></pre>
<p>如果一个结构体的字段是一个结构体或者枚举，请为它加上一层 <code>Box</code>, 否则会导致编译时错误。例如 <code>struct A {b: B}</code> 应该使用
<code>struct A {b: Box&lt;B&gt;}</code> 代替。</p>
<h2 id="元组结构体"><a class="header" href="#元组结构体">元组结构体</a></h2>
<p>元组结构体 <code>struct Foo(A, B)</code> 会被翻译为 <code>class Foo { A field0; B field1; }</code>, 因为 Dart
没有匿名字段。</p>
<h2 id="non-final-字段"><a class="header" href="#non-final-字段">Non-final 字段</a></h2>
<p>在结构体字段上添加 <code>#[(non_final)]</code>, Dart 中对应的字段就会是 non-final 的。默认情况下，所有生成的字段都被设为
final，因为 Rust 默认是不可变的。</p>
<h2 id="dart-元数据注释"><a class="header" href="#dart-元数据注释">Dart 元数据注释</a></h2>
<p>你可以使用 <code>frb</code> 宏中的 <code>dart_metadata</code> 参数为 dart 添加元数据注解。</p>
<ul>
<li>
<p>对于那些由 dart 提前引入的注解（例如 <code>@deprecated</code>）,只需将注解作为一个 Rust 字面量。</p>
<blockquote>
<p>TODO! For annotations that are prelude by dart (e.g. <code>@deprecated</code>), just
put annotation as a Rust literal.</p>
</blockquote>
</li>
<li>
<p>如果你需要使用 import, 请把 import 部分的代码追加到注解字面量之后。目前支持两种 import 格式：</p>
<ul>
<li><code>import 'somepackage'</code></li>
<li><code>import 'somepackage' as somename</code>, <code>somename</code> 部分会成为注解的前缀</li>
</ul>
</li>
<li>
<p>多个注解间使用 <code>,</code> 分割</p>
</li>
</ul>
<p>具体的例子如下。</p>
<h2 id="freezed-dart-classes"><a class="header" href="#freezed-dart-classes"><code>freezed</code> Dart classes</a></h2>
<p>如果你想让生成的 Dart 类是 <a href="https://pub.dev/packages/freezed"><code>freezed</code></a>的（类似于 Kotlin 中的
data-classes），只需要在结构体前添加 <code>#[frb(dart_metadata=(&quot;freezed&quot;))]</code>，它会为你生成需要的东西。</p>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<h3 id="例-1--递归字段"><a class="header" href="#例-1--递归字段">例 1 : 递归字段</a></h3>
<pre><code class="language-rust noplayground">pub struct MyTreeNode {
    pub value: Vec&lt;u8&gt;,
    pub children: Vec&lt;MyTreeNode&gt;,
}
</code></pre>
<p>转换为：</p>
<pre><code class="language-Dart">class MyTreeNode {
  final Uint8List value;
  final List&lt;MyTreeNode&gt; children;
  MyTreeNode({required this.value, required this.children});
}
</code></pre>
<p>注意：如果你想了解 <code>Future</code> , 请看这里 <a href="feature/async_dart.html">async_dart</a>.</p>
<h3 id="例-2--metadata"><a class="header" href="#例-2--metadata">例 2 : Metadata</a></h3>
<pre><code class="language-rust noplayground">#[frb(dart_metadata=(&quot;freezed&quot;, &quot;immutable&quot; import &quot;package:meta/meta.dart&quot; as meta))]
pub struct UserId {
    pub value: u32,
}
</code></pre>
<p>转换为：</p>
<pre><code class="language-dart">import 'package:meta/meta.dart' as meta;

@freezed
@meta.immutable
class UserId with _$UserId {
  const factory UserId({
    required int value,
  }) = _UserId;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p>众所周知，Rust 的 <code>enum</code> 功能强大，而且表达力强 - 它允许每一个枚举的变体关联不同的数据。Dart 没有内置这种枚举，但是不用担心 - 我们会使用
Dart 中的 <code>freezed</code> 库自动翻译为等价的结构。第一眼看上去，<code>freezed</code> 的语法可能看上去很奇怪，但是请阅读一下
<a href="https://pub.dev/packages/freezed">它的文档</a>, 看看它的强大之处。</p>
<h2 id="示例-1"><a class="header" href="#示例-1">示例</a></h2>
<pre><code class="language-rust noplayground">pub enum KitchenSink {
    Empty,
    Primitives {
        /// Dart field comment
        int32: i32,
        float64: f64,
        boolean: bool,
    },
    Nested(Box&lt;KitchenSink&gt;),
    Optional(
        /// Comment on anonymous field
        Option&lt;i32&gt;,
        Option&lt;i32&gt;,
    ),
    Buffer(ZeroCopyBuffer&lt;Vec&lt;u8&gt;&gt;),
    Enums(Weekdays),
}
</code></pre>
<p>转换为：</p>
<pre><code class="language-Dart">@freezed
class KitchenSink with _$KitchenSink {
  /// Comment on variant
  const factory KitchenSink.empty() = Empty;
  const factory KitchenSink.primitives({
    /// Dart field comment
    required int int32,
    required double float64,
    required bool boolean,
  }) = Primitives;
  const factory KitchenSink.nested(
    KitchenSink field0,
  ) = Nested;
  const factory KitchenSink.optional([
    /// Comment on anonymous field
    int? field0,
    int? field1,
  ]) = Optional;
  const factory KitchenSink.buffer(
    Uint8List field0,
  ) = Buffer;
  const factory KitchenSink.enums(
    Weekdays field0,
  ) = Enums;
}
</code></pre>
<p>它们由 freezed 中的 <a href="https://pub.dev/packages/freezed">all functionalities</a> 驱动。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="外部类型"><a class="header" href="#外部类型">外部类型</a></h1>
<h2 id="定义在相同-crate-中不同文件里的类型"><a class="header" href="#定义在相同-crate-中不同文件里的类型">定义在相同 crate 中不同文件里的类型</a></h2>
<p><code>use</code> 语句可以正常使用。例如：添加 <code>use crate::data::{MyEnum, MyStruct};</code>后，你可以正常的使用 <code>MyEnum</code> 和
<code>MyStruct</code>。</p>
<h3 id="示例-2"><a class="header" href="#示例-2">示例</a></h3>
<pre><code class="language-rust noplayground">use crate::data::{MyEnum, MyStruct};

pub fn use_imported_things(my_struct: MyStruct, my_enum: MyEnum) { ... }
</code></pre>
<p>转换为：</p>
<pre><code class="language-Dart">// Well it just behaves normally as you expect
Future&lt;void&gt; useImportedThings({required MyStruct myStruct, required MyEnum myEnum});
</code></pre>
<p>注意：如果你对 <code>Future</code> 感兴趣，请看 <a href="feature/async_dart.html">这里</a>.</p>
<h2 id="其他-crate-中的类型"><a class="header" href="#其他-crate-中的类型">其他 crate 中的类型</a></h2>
<p>这个功能被称为 &quot;镜像 (mirror)&quot;. 简单来说，对于你想使用的外部类型，你需要重新编写一次作为镜像。这个镜像只会在代码生成时负责告知
<code>flutter_rust_bridge</code> 所需的类型信息。下面的例子里有详细的语法。</p>
<p>不用担心它会打破 DRY (Don’t Repeat Yourself) 原则，也不用担心你可能写错一个字段。因为如果镜像和原始类型不完全一致就会导致编译错误。</p>
<p>更多信息： <a href="https://github.com/fzyzcjy/flutter_rust_bridge/pull/352">#352</a></p>
<p>当多个结构体有相同的字段时，你可以使用下面的语法只重写一遍。
<code>#[frb(mirror(FirstStruct, SecondStruct, ThirdStruct))]</code>.
(<a href="https://github.com/fzyzcjy/flutter_rust_bridge/pull/619">#619</a>)</p>
<h3 id="示例-3"><a class="header" href="#示例-3">示例</a></h3>
<!-- TODO! -->
<pre><code class="language-rust noplayground">// Mirroring example:
// The goal of mirroring is to use external objects without needing to convert them with an intermediate type
// In this case, the struct ApplicationSettings is defined in another crate (called external-lib)

// To use an external type with mirroring, it MUST be imported publicly (aka. re-export)
pub use external_lib::{ApplicationEnv, ApplicationMode, ApplicationSettings};

// To mirror an external struct, you need to define a placeholder type with the same definition
#[frb(mirror(ApplicationSettings))]
pub struct _ApplicationSettings {
    pub name: String,
    pub version: String,
    pub mode: ApplicationMode,
    pub env: Box&lt;ApplicationEnv&gt;,
}

// It works with basic enums too
// Enums with struct variants are not yet supported
#[frb(mirror(ApplicationMode))]
pub enum _ApplicationMode {
    Standalone,
    Embedded,
}

#[frb(mirror(ApplicationEnv))]
pub struct _ApplicationEnv {
    pub vars: Vec&lt;String&gt;,
}

// This function can directly return an object of the external type ApplicationSettings because it has a mirror
pub fn get_app_settings() -&gt; ApplicationSettings {
    external_lib::get_app_settings()
}

// Similarly, receiving an object from Dart works. Please note that the mirror definition must match entirely and the original struct must have all its fields public.
pub fn is_app_embedded(app_settings: ApplicationSettings) -&gt; bool {
    // println!(&quot;env: {}&quot;, app_settings.env.vars[0]);
    match app_settings.mode {
        ApplicationMode::Standalone =&gt; false,
        ApplicationMode::Embedded =&gt; true,
    }
}
</code></pre>
<p>用一个结构体去镜像多个结构体：</p>
<pre><code class="language-rust noplayground">// *不* 需要这样做
#[frb(mirror(MessageId))]
pub struct MId(pub [u8; 32]);
#[frb(mirror(BlobId))]
pub struct BId(pub [u8; 32]);
#[frb(mirror(FeedId))]
pub struct FId(pub [u8; 32]);

// 只要编写一次就足够了
#[frb(mirror(MessageId, BlobId, FeedId))]
pub struct Id(pub [u8; 32]);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option">Option</a></h1>
<p>Dart 对于可能为空的字段有特殊的语法 <code>?</code>，该库会自动把 <code>Option</code> 翻译为 <code>?</code>。你可以查看
<a href="https://dart.dev/null-safety">官方文档</a> 了解更多。</p>
<p>此外，<code>flutter_rust_bridge</code> 也能够处理 Dart 中的 <code>required</code> 关键字：如果一个参数不能为空，它就会被标记为
<code>required</code>。如果它可以为空，那就不需要 <code>required</code>，Dart 默认为 null。</p>
<h2 id="示例-4"><a class="header" href="#示例-4">示例</a></h2>
<pre><code class="language-rust noplayground">pub struct Element {
    pub tag: Option&lt;String&gt;,
    pub text: Option&lt;String&gt;,
    pub attributes: Option&lt;Vec&lt;Attribute&gt;&gt;,
    pub children: Option&lt;Vec&lt;Element&gt;&gt;,
}

pub fn parse(mode: String, document: Option&lt;String&gt;) -&gt; Option&lt;Element&gt; { ... }
</code></pre>
<p>转换为：</p>
<pre><code class="language-Dart">Future&lt;Element?&gt; handleOptionalStruct({required String mode, String? document});

class Element {
  final String? tag;
  final String? text;
  final List&lt;Attribute&gt;? attributes;
  final List&lt;Element&gt;? children;
  Element({this.tag, this.text, this.attributes, this.children});
}
</code></pre>
<p>注意：如果你对 <code>Future</code> 感兴趣，请看 <a href="feature/async_dart.html">这里</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法"><a class="header" href="#方法">方法</a></h1>
<p>支持带有方法的结构体。包括静态方法和非静态方法。</p>
<h2 id="示例-5"><a class="header" href="#示例-5">示例</a></h2>
<pre><code class="language-rust noplayground">pub struct SumWith { pub x: u32 }

impl SumWith {
    pub fn sum(&amp;self, y: u32) -&gt; u32 { self.x + y }
    pub fn sum_static(x: u32, y: u32) -&gt; u32 { x + y }
}
</code></pre>
<p>转换为</p>
<pre><code class="language-Dart">class SumWith {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  final int x;

  SumWith({
    required this.bridge,
    required this.x,
  });

  Future&lt;int&gt; sum({required int y, dynamic hint}) =&gt; ..
  static Future&lt;int&gt; sum({required int x, required int y, dynamic hint}) =&gt; ..
}
</code></pre>
<p>注意：如果你对 <code>Future</code> 感兴趣，请看 <a href="feature/async_dart.html">这里</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="返回值类型"><a class="header" href="#返回值类型">返回值类型</a></h1>
<p>返回值类型可以是 <code>anyhow::Result&lt;YourType&gt;</code>, 或者直接是你的类型 <code>YourType</code> .</p>
<h2 id="示例-6"><a class="header" href="#示例-6">示例</a></h2>
<pre><code class="language-rust noplayground">pub fn f(a: i32, b: i32) -&gt; i32 { a + b }

pub fn g(a: i32, b: i32) -&gt; anyhow::Result&lt;i32&gt; { Ok(a + b) }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="零拷贝"><a class="header" href="#零拷贝">零拷贝</a></h1>
<p><code>ZeroCopyBuffer&lt;Vec&lt;u8&gt;&gt;</code> (以及与它类似的东西，比如 <code>ZeroCopyBuffer&lt;Vec&lt;i8&gt;&gt;</code>) 可以无需拷贝将数据从
Rust 发送到 Dart. 因此，可以节约拷贝数据的开销，如果你的数据很大（比如一张高分辨率图像），开销可能会很高。</p>
<h2 id="示例-7"><a class="header" href="#示例-7">示例</a></h2>
<pre><code class="language-rust noplayground">pub fn draw_tree(tree: Vec&lt;TreeNode&gt;) -&gt; ZeroCopyBuffer&lt;Vec&lt;u8&gt;&gt; { ... }
</code></pre>
<p>转换为：</p>
<pre><code class="language-Dart">Future&lt;Uint8List&gt; drawTree({required List&lt;TreeNode&gt; tree});
</code></pre>
<p>生成的 Dart 代码看起来和没有用 <code>ZeroCopyBuffer</code> 的几乎一样。但是它的内部实现已经改变，完全不需要内存拷贝！</p>
<p>注意：如果你对 <code>Future</code> 感兴趣，请看 <a href="feature/async_dart.html">这里</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stream-流--迭代器"><a class="header" href="#stream-流--迭代器">Stream 流 / 迭代器</a></h1>
<p><em><code>Stream</code> / <code>Iterator</code></em></p>
<p>Stream 是什么？简单来说：调用一次，返回多次，类似于 Iterator。</p>
<blockquote>
<p>译者注：异步 Iterator。</p>
</blockquote>
<p>Flutter 的 <a href="https://dart.dev/tutorials/language/streams">Stream</a> 是一个强大的抽象。</p>
<p>假如，你的 Rust 代码在运行一个十分复杂的算法，并且每隔几百毫秒，就能找到一种新的解决方案。每找到一个解，它就可以直接将这部分内容回复给
Flutter，并立即渲染到 UI。用户无需等到算法完全结束就能看到一部分结果。</p>
<p>至于细节方面，一个带有下面函数签名的 Rust 函数 <code>fn f(sink: StreamSink&lt;T&gt;, ..) -&gt; Result&lt;()&gt;</code>
会被翻译为：<code>Stream&lt;T&gt; f(..)</code>。</p>
<!-- TODO! -->
<p>注意：你可以永远持有这个 <code>StreamSink</code>，并且自由使用，甚至在 Rust 函数返回后。下面的 logger
例子证明了这点（<code>create_log_stream</code> 函数几乎是立即返回，但是你可以在一小时之后使用 <code>StreamSink</code>）。</p>
<blockquote>
<p>Notice that, you can hold that StreamSink forever, and use it freely even
after the Rust function itself returns. The logger example below also
demonstrates this (the create_log_stream returns almost immediately, while you
can use the StreamSink after, say, an hour).</p>
</blockquote>
<p><code>StreamSink</code> 可以被放在函数的任何地方。例如 <code>fn f(a: i32, b: StreamSink&lt;String&gt;)</code> 和
<code>fn f(a: StreamSink&lt;String&gt;, b: i32)</code> 都是合法的。</p>
<h2 id="示例-8"><a class="header" href="#示例-8">示例</a></h2>
<p>下面的例子只是为了加深你对 Stream 特性的理解。</p>
<h3 id="示例适用于生产环境的-logger"><a class="header" href="#示例适用于生产环境的-logger">示例：适用于生产环境的 Logger</a></h3>
<p>在我的 app（已经应用在生产环境）里，我使用了下面的策略处理 Rust 日志：使用常规的 Rust 方法记录日志，比如 <code>info!</code> 和 <code>debug!</code>
宏。接着日志会在两个地方得到处理：一方面是通过不同平台特定的方法打印（就像安卓平台的 Logcat 和 IOS 的 NSLog）另一个是通过 Stream
发送到 Dart 端并进一步处理 (例如保存到文件，或者是发送给服务端等)。</p>
<p>完整的代码可以在这里查看<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/486">#486</a>。</p>
<h3 id="示例简单的-logger"><a class="header" href="#示例简单的-logger">示例：简单的 logger</a></h3>
<p>让我们实现了一个简单的日志系统（改编自我在生产环境中使用 <code>flutter_rust_bridge</code> 构建的日志系统），Rust 代码可以向 Dart
端发送日志。</p>
<p>Rust 端 <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">pub struct LogEntry {
    pub time_millis: i64,
    pub level: i32,
    pub tag: String,
    pub msg: String,
}

// 用于展示的简化代码
// 为了成功编译，你需要一个 OnceCell，或者 Mutex，或者 RwLock
// 更多资料：https://github.com/fzyzcjy/flutter_rust_bridge/issues/398
lazy_static! { static ref log_stream_sink: StreamSink&lt;LogEntry&gt;; }

pub fn create_log_stream(s: StreamSink&lt;LogEntry&gt;) {
    stream_sink = s;
}
</code></pre>
<p>现在 Rust 编译器应该会向你抱怨 <code>LogEntry</code> 没有实现 <code>IntoDart</code>。这是符合预期的，因为 <code>flutter_rust_bridge</code>
会为你生成相关实现。修复它也很简单，再次运行 <code>flutter_rust_bridge_codegen</code> 即可</p>
<p>生成的 Dart 代码：</p>
<pre><code class="language-Dart">Stream&lt;LogEntry&gt; createLogStream();
</code></pre>
<p>在 Dart 中使用：</p>
<pre><code class="language-dart">Future&lt;void&gt; setup() async {
    createLogStream().listen((event) {
      print('log from rust: ${event.level} ${event.tag} ${event.msg} ${event.timeMillis}');
    });
}
</code></pre>
<p>现在我们能够愉快的在 Rust 中用日志记录任何东西：</p>
<pre><code class="language-rust noplayground">log_stream_sink.add(LogEntry { msg: &quot;hello I am a log from Rust&quot;, ... })
</code></pre>
<p>当然了，你也可以跟着 Rust 中的 <code>log</code> 库去实现一个自己的 logger，只需要在外面包装一层 stream sink，就可以使用标准的 Rust
日志机制，例如 <code>info!</code>。我在我在我的项目中就是这么做的。</p>
<h3 id="示例简单定时器"><a class="header" href="#示例简单定时器">示例：简单定时器</a></h3>
<p>Credits:
<a href="https://gist.github.com/Desdaemon/be5da0a1c6b4724f20093ef434959744">this</a> and
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/347">#347</a>.</p>
<pre><code class="language-rust noplayground">use anyhow::Result;
use std::{thread::sleep, time::Duration};

use flutter_rust_bridge::StreamSink;

const ONE_SECOND: Duration = Duration::from_secs(1);

// can't omit the return type yet, this is a bug
pub fn tick(sink: StreamSink&lt;i32&gt;) -&gt; Result&lt;()&gt; {
    let mut ticks = 0;
    loop {
        sink.add(ticks);
        sleep(ONE_SECOND);
        if ticks == i32::MAX {
            break;
        }
        ticks += 1;
    }
    Ok(())
}
</code></pre>
<p>然后在 Dart 中使用：</p>
<pre><code class="language-dart">import 'package:flutter/material.dart';
import 'ffi.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(title: 'Flutter Demo Home Page'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({Key? key, required this.title}) : super(key: key);
  final String title;

  @override
  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();
}

class _MyHomePageState extends State&lt;MyHomePage&gt; {
  late Stream&lt;int&gt; ticks;

  @override
  void initState() {
    super.initState();
    ticks = api.tick();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: &lt;Widget&gt;[
            const Text(&quot;Time since starting Rust stream&quot;),
            StreamBuilder&lt;int&gt;(
              stream: ticks,
              builder: (context, snap) {
                final style = Theme.of(context).textTheme.headline4;
                final error = snap.error;
                if (error != null)
                  return Tooltip(
                      message: error.toString(),
                      child: Text('Error', style: style));

                final data = snap.data;
                if (data != null) return Text('$data second(s)', style: style);

                return const CircularProgressIndicator();
              },
            )
          ],
        ),
      ),
    );
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dart-中的异步"><a class="header" href="#dart-中的异步">Dart 中的异步</a></h1>
<p>默认情况下，生成的代码都是异步的。所以 <code>fn f(..) -&gt; String</code> 将被转换为 <code>Future&lt;String&gt; f(..)</code>，多了一个
<code>Future</code>。</p>
<p>为什么？Flutter UI 是单线程的。如果你使用同步方法（一些老的 binding 就是这样），在 Rust 代码执行时，UI 渲染将被阻塞。如果你的
Rust 代码进行一次复杂运算需要耗时 100ms，那么你的 UI 就会完全冻结 100ms，用户就不乐意了。</p>
<p>另一方面，有了生成的异步 Dart 绑定，你就可以在 Dart/Flutter 的主隔离区直接调用，Rust 代码不会阻塞 Flutter UI。</p>
<p>async 和 <code>Future</code> 在 Flutter/Dart 中几乎无处不在，并且有着非常好的内部支持，完全不用担心 :D。</p>
<p>注意：一个常见的误解是在 Dart 的其他隔离区调用 Rust 代码（例如
&quot;线程&quot;），而不是主隔离区。这是完全没必要的，只会徒增你的心智负担。如上所述，即使你的 Rust 只用 100ms 就能完成，async 也只需要花费 0.1
ms，并且不会阻塞你的 UI。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dart-中的同步"><a class="header" href="#dart-中的同步">Dart 中的同步</a></h1>
<p>如果你真的需要生成同步的 Dart 函数，你可以使用 <code>SyncReturn&lt;Vec&lt;u8&gt;&gt;</code> 作为返回值类型。</p>
<p>我们建议只在非常快的 Rust 函数上这样做，否则 UI 将被阻塞。</p>
<p>因为同步 Dart 函数使用得很少，所以现在仅支持 <code>Vec&lt;u8&gt;</code> 一种类型，其他类型可以通过序列化实现，例如 JSON 和
Protobuf。注意，这种方法极少用到，99% 的 <code>flutter_rust_bridge</code> 都不会用到。如果你需要其他类型支持，请提交一个
issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并发"><a class="header" href="#并发">并发</a></h1>
<p>多个 Rust 函数能够同时运行，并且是并发的运行。因为我们默认会使用一个线程池去执行 Rust
代码。但是，你可以完全自定义这里的行为（甚至是完全舍弃线程池）。</p>
<h2 id="示例-9"><a class="header" href="#示例-9">示例</a></h2>
<p>看一下下面的例子：</p>
<pre><code class="language-rust noplayground">pub fn compute() {
  thread::sleep(Duration::from_millis(1000));
}
</code></pre>
<p>下面的 Dart 代码使用了它：</p>
<pre><code class="language-dart">var a = compute();
var b = compute();
var c = compute();
await Future.wait([a, b, c]); // 你可能需要提前学习 Dart 中的 `Future` and `async` 读懂这行代码
</code></pre>
<p>总体运行时间是 1s 而不是 3s，因为多个 <code>compute</code> 函数是并发执行的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handler"><a class="header" href="#handler">Handler</a></h1>
<p>默认情况下，frb 使用 <code>DefaultHandler</code>，你可以实现你自己的 <code>Handler</code> 做你想做的事情。首先，你需要在 Rust 文件中创建一个名为
<code>FLUTTER_RUST_BRIDGE_HANDLER</code> 的变量（可能会用到 <code>lazy_static</code>）。接着，你不一定需要创建一个新的实现了
<code>Handler</code> 的结构体，只需要利用现有的 <code>SimpleHandler</code>，并自定义它的泛型参数，例如<code>Executor</code>。</p>
<h2 id="示例-10"><a class="header" href="#示例-10">示例</a></h2>
<h3 id="例-1-除了-dart-之外同时向你的后端报告错误"><a class="header" href="#例-1-除了-dart-之外同时向你的后端报告错误">例 1: 除了 Dart 之外，同时向你的后端报告错误</a></h3>
<pre><code class="language-rust noplayground">pub struct MyErrorHandler(ReportDartErrorHandler);

impl ErrorHandler for MyErrorHandler {
    fn handle_error(&amp;self, port: i64, error: handler::Error) {
        send_error_to_your_backend(&amp;error);
        self.0.handle_error(port, error)
    }

    ...
}
</code></pre>
<h3 id="例-2-记录函数执行开始和结束的时间"><a class="header" href="#例-2-记录函数执行开始和结束的时间">例 2: 记录函数执行开始和结束的时间</a></h3>
<pre><code class="language-rust noplayground">pub struct MyExecutor(ThreadPoolExecutor&lt;MyErrorHandler&gt;);

impl Executor for MyExecutor {
    fn execute&lt;TaskFn, TaskRet&gt;(&amp;self, wrap_info: WrapInfo, task: TaskFn) {
        let debug_name_string = wrap_info.debug_name.to_string();
        self.thread_pool_executor
            .execute(wrap_info, move |task_callback| {
                Self::log_around(&amp;debug_name_string, move || task(task_callback))
            })
    }
}

impl MyExecutor {
    fn log_around&lt;F, R&gt;(debug_name: &amp;str, f: F) -&gt; R where F: FnOnce() -&gt; R {
        let start = Instant::now();
        debug!(&quot;(Rust) execute [{}] start&quot;, debug_name);
        let ret = f();
        debug!(&quot;(Rust) execute [{}] end delta_time={}ms&quot;, debug_name, start.elapsed().as_millis());
        ret
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="初始化"><a class="header" href="#初始化">初始化</a></h1>
<p>如果你需要这个特性，去看一下 Flutter 侧的 <code>FlutterRustBridgeSetupMixin</code> （文档尚未完成，如果你有问题，记得创建一个
issue）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-中的异步"><a class="header" href="#rust-中的异步">Rust 中的异步</a></h1>
<p>如果你想在 Rust 中使用 async / await 或者是返回一个 Future，请看
<a href="feature/../article/async_in_rust.html">这个文档</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多文件"><a class="header" href="#多文件">多文件</a></h1>
<p>在大型项目中，把所有的文件都放在一个 <code>api.rs</code> 是不够的，我们通常想把它分离到 <code>api_of_one_module.rs</code>,
<code>api_of_another_module.rs</code> 等多个文件里。</p>
<p>你只需要指定所有的 Rust 输入文件以及输出位置即可，这里有一个例子：</p>
<pre><code class="language-shell">flutter_rust_bridge_codegen \
  --rust-input &quot;$REPO_DIR/native/src/api_1.rs&quot; &quot;$REPO_DIR/native/src/api_2.rs&quot; \
  --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_1.dart&quot; &quot;$REPO_DIR/lib/bridge_generated_api_2.dart&quot; \
  --class-name ApiClass1 ApiClass2 \
  --rust-output generated_api_1 generated_api_2
</code></pre>
<p>更多信息在 <a href="feature/../article/generate_multiple_files.html">这篇文章</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-buildrs-中运行"><a class="header" href="#在-buildrs-中运行">在 <code>build.rs</code> 中运行</a></h1>
<p>执行代码生成器有两种方法。第一种也是最明显的方法是直接在命令行中执行 <code>flutter_rust_bridge</code>。</p>
<p>另一种方法时集成到 <code>build.rs</code> 里。通过这种方法，代码生成器会在编译 Rust 项目时自动触发。更多信息请看
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/rust/build.rs">build.rs</a>
文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可取消的任务"><a class="header" href="#可取消的任务">可取消的任务</a></h1>
<p>当 Rust 代码的计算量很大时，你可能会在中途想要取消 (例如用户中途点击了取消)，这样就能节约宝贵的计算资源。</p>
<p>安装：目前，该功能已经完成，并且我已经在我自己的 app 中使用了很长时间。（但是我并没有将这个 PR 合并到主分支，因为我需要时间决定如何把这部分代码放到
<code>api.rs</code> 中），因此如果你需要的话，请直接将
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/pull/333">这里的代码 (#333)</a>
复制到你的项目里，然后像平常一样使用即可。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="对象池"><a class="header" href="#对象池">对象池</a></h1>
<p>当你的 Rust 侧有一些大型的对象时，你可能不想让它在 Rust 和 Dart 之间反复复制。这是，对象池就派上用场了：你只需要在 Rust 和 Dart
之间传递一个 &quot;对象句柄&quot;（实际上只是几个整数），Rust 会把这个句柄转换为真实的对象。</p>
<p>安装：和 <a href="feature/cancelable_task.html">cancelable tasks</a> 一样，请查看文档。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="杂项"><a class="header" href="#杂项">杂项</a></h1>
<h2 id="把生成代码的定义和实现分开"><a class="header" href="#把生成代码的定义和实现分开">把生成代码的定义和实现分开</a></h2>
<p>生成的 <code>bridge_generated.dart</code> 文件默认情况下会包含 API 的定义和实现。在生成时，加上 <code>--dart-decl-output</code>
参数，它们就会被分开，并且定义中不会包含任何类似于 <code>dart:ffi</code> 的东西。</p>
<p>更多信息：<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/298">#298</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从模板创建新项目"><a class="header" href="#从模板创建新项目">从模板创建新项目</a></h1>
<p>在这一章里，我们将从模板创建你自己的项目。看起来有点长，这只是因为我们想讲清楚你可能遇到的每个细节。</p>
<p><strong>注意:</strong> 虽然过程很复杂，但是绝大多数原因都不是来源于该库本身，使用原始的 Rust/Flutter FFI 和它一样复杂。换句话说，真正耗时的是搭建
Dart/Flutter + Rust 工具链。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建一个新项目"><a class="header" href="#创建一个新项目">创建一个新项目</a></h1>
<p>首先使用 <a href="https://github.com/Desdaemon/flutter_rust_bridge_template">flutter_rust_bridge_template</a> 的模板创建一个仓库。这个模板在大多数 Flutter 支持的平台应该可以通过
<code>flutter run</code> 直接运行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安卓设置"><a class="header" href="#安卓设置">安卓设置</a></h1>
<p>对于安卓平台，你需要安装一部分组件：</p>
<h2 id="rust-编译目标"><a class="header" href="#rust-编译目标">Rust 编译目标</a></h2>
<p>交叉编译到安卓需要一些额外的组件，你可以通过下面的命令安装：</p>
<pre><code class="language-shell">rustup target add \
    aarch64-linux-android \
    armv7-linux-androideabi \
    x86_64-linux-android \
    i686-linux-android
</code></pre>
<h2 id="jdk-8"><a class="header" href="#jdk-8">JDK 8</a></h2>
<p>Android Studio 依赖于 <code>javax</code> 库存在于 Java 运行时，验证安装成功的唯一可靠的方法是安装一个老版本的 Java。在类 Unix
系统上，你可以使用 <a href="https://asdf-vm.com/">asdf</a> 或者类似的工具去管理你的 Java 版本。模板在 <code>.tool-versions</code>
文件中定义了一个已知的可以正常运行的 Java 版本。</p>
<blockquote>
<p>译者注：<code>asdf</code> 是一个版本管理工具，<code>.tool-versions</code> 是 asdf 的配置文件</p>
</blockquote>
<h2 id="android-ndk"><a class="header" href="#android-ndk"><a href="https://developer.android.com/ndk">Android NDK</a></a></h2>
<p>安装：</p>
<blockquote>
<p>Android Studio &gt; SDK Manager &gt; SDK Tools &gt; uncheck Hide Obsolete Packages &gt;
NDK (version 22)</p>
</blockquote>
<blockquote>
<p>译者注：您也可以不下载 Android Studio，直接通过 sdkmanager 在命令行安装。</p>
</blockquote>
<p><a href="https://developer.android.com/ndk">Android NDK</a>, 或者说 Native Development Kit, 确保了使用其他语言编写的代码可以通过 JNI 或者说
<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">Java Native Interface</a> 运行在 JVM 上。我们会把 Cargo 创建的动态连接库和项目的打包结果打包在一起。</p>
<p>跟着上面的步骤，你应该会把 NDK 安装到了 <code>$ANDROID_SDK_HOME/ndk</code> 文件夹，ANDROID_SDK_HOME 通常是：</p>
<ul>
<li>Windows: <code>%APPDATA%\Local\Android\sdk</code></li>
<li>MacOS: <code>~/Library/Android/sdk</code></li>
<li>Linux: 通过设置环境变量 ANDROID_SDK_HOME, 或者 <code>~/Android/sdk</code></li>
</ul>
<p><a href="https://github.com/rust-lang/rust/pull/85806">An issue</a> 在构建 Rust <code>core</code> 库时，只有 NDK 22 和更早版本可以使用。</p>
<h2 id="android_ndk-gradle-配置"><a class="header" href="#android_ndk-gradle-配置"><code>ANDROID_NDK</code> Gradle 配置</a></h2>
<pre><code class="language-shell">echo &quot;ANDROID_NDK=(path to NDK)&quot; &gt;&gt; ~/.gradle/gradle.properties
</code></pre>
<p>下一步，你需要设置 NDK 对 Gradle 可见。根据你的系统有不同的设置方法，但是一般都可以在 <code>~/.gradle/gradle.properties</code>
里配置以下内容：</p>
<pre><code>ANDROID_NDK=(path to NDK)
</code></pre>
<p>或者是修改当前项目文件夹，android 目录里的同名文件。</p>
<h2 id="cargo-ndk"><a class="header" href="#cargo-ndk"><a href="https://github.com/bbqsrc/cargo-ndk">cargo-ndk</a></a></h2>
<pre><code class="language-shell">cargo install cargo-ndk --version 2.6.0
</code></pre>
<p><a href="https://github.com/bbqsrc/cargo-ndk">cargo-ndk</a> 是一个 cargo 插件，它能够将代码编译到适合的 JNI 而不需要额外的配置。运行上述命令进行安装。cargo-ndk 2.7.0
版本引入了一些变化，破坏了对 NDK 22 版本的支持，所以 目前必须使用 2.6.0。</p>
<h2 id="可选的-ndk-设置"><a class="header" href="#可选的-ndk-设置">可选的 NDK 设置</a></h2>
<p>你也可以选择最新版本的 NDK，它比 22 版本要好。但是你需要 Hack
部分代码去解决一个报错：<a href="https://github.com/bbqsrc/cargo-ndk/issues/22">unable to find library -lgcc error</a>.</p>
<h3 id="android-ndk-1"><a class="header" href="#android-ndk-1">Android NDK</a></h3>
<p>安装最新版本的 NDK:</p>
<blockquote>
<p>Android Studio &gt; SDK Manager &gt; SDK Tools &gt; NDK (Side by side)</p>
</blockquote>
<h3 id="cargo-ndk-1"><a class="header" href="#cargo-ndk-1"><a href="https://github.com/bbqsrc/cargo-ndk">cargo-ndk</a></a></h3>
<p>如果你使用的是版本高于 22 的 NDK，那么你需要 <code>cargo-ndk</code> 2.7.0 或者更新版本。</p>
<pre><code>cargo install cargo-ndk --version ^2.7.0
</code></pre>
<p>A workaround may be under development in the cargo-ndk project. Until it is
finished, you need to manually create four text files to redirect calls from
libgcc to libunwind (<a href="https://github.com/rust-lang/rust/pull/85806#issuecomment-1096266946">reference</a>):</p>
<ol>
<li>
<p>Find out all the 4 folders containing file <code>libunwind.a</code>.</p>
<ul>
<li>
<p>On Windows, it is similar to:</p>
<pre><code>C:\Users\Administrator\AppData\Local\Android\Sdk\ndk\24.0.8215888\toolchains\llvm\prebuilt\windows-x86_64\lib64\clang\14.0.1\lib\linux\x86_64\
</code></pre>
</li>
<li>
<p>On macOS Monterey, it is similar to:</p>
<pre><code>~/Library/Android/sdk/ndk/24.0.8215888/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/14.0.1/lib/linux/x86_64/
</code></pre>
</li>
</ul>
<p>The three other folders end with <code>aarch64</code>, <code>arm</code>, <code>i386</code> instead of
<code>x86_64</code>.</p>
</li>
<li>
<p>Create 4 text files named <code>libgcc.a</code> in the four folders mentioned above with
this contents</p>
<pre><code>INPUT(-lunwind)
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios-设置"><a class="header" href="#ios-设置">iOS 设置</a></h1>
<p>iOS 需要一些额外的交叉编译目标：</p>
<pre><code class="language-bash"># 64 bit targets (真机 &amp; 模拟器):
rustup target add aarch64-apple-ios x86_64-apple-ios
# New simulator target for Xcode 12 and later
rustup target add aarch64-apple-ios-sim
# 32 bit targets (你应该不需要这个):
rustup target add armv7-apple-ios i386-apple-ios
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-设置"><a class="header" href="#web-设置">Web 设置</a></h1>
<p>目前为止，Web 支持尚未完成
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/315">fzyzcjy/flutter_rust_bridge#315</a>。</p>
<p>考虑一下评论或者建议让我们了解您对该功能的需求！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-和-linux"><a class="header" href="#windows-和-linux">Windows 和 Linux</a></h1>
<p>Windows 和 Linux 共享同一套编译系统（CMake），从零开始设置这两个平台也非常简单。模板该模板使用到了 <a href="https://github.com/corrosion-rs/corrosion">Corrosion</a>
库来加快这一过程，安装 Corrosion 需要先克隆代码，并初始化。跟着 <a href="https://github.com/corrosion-rs/corrosion#installation">本指南</a> 学习如何将 <a href="https://github.com/corrosion-rs/corrosion">Corrosion</a>
安装到你的系统上。安装完成后，请继续修改 <code>rust.cmake</code>。</p>
<pre><code class="language-diff">-# find_package(Corrosion REQUIRED)
+find_package(Corrosion REQUIRED)

-include(FetchContent)
-
-FetchContent_Declare(
-    Corrosion
-    GIT_REPOSITORY https://github.com/AndrewGaspar/corrosion.git
-    GIT_TAG origin/master # Optionally specify a version tag or branch here
-)
-
-FetchContent_MakeAvailable(Corrosion)
</code></pre>
<h2 id="troubleshooting-cmake-on-linux"><a class="header" href="#troubleshooting-cmake-on-linux">Troubleshooting: CMake on Linux</a></h2>
<p><a href="https://github.com/corrosion-rs/corrosion">Corrosion</a> 对 CMake 的最低版本需求是 3.12，这不是 <code>CMakeLists.txt</code> 的默认版本。所以你需要手动修改
<code>linux/CMakeLists.txt</code>:</p>
<pre><code class="language-diff">-cmake_minimum_required(VERSION 3.10)
+cmake_minimum_required(VERSION 3.12)
</code></pre>
<p>但是它带来了另一个问题，它不允许你通过 Flutter SDK 通过 Snap 构建，因为他的构建过程和 CMake 3.10
绑定。可能的话，建议使用命令行手动安装
Flutter。<a href="https://github.com/canonical/flutter-snap/pull/61">canonical/flutter-snap#61</a>
地。</p>
<p>一个变通的方法是忽略 <code>rust.cmake</code> 并手动配置 CMake 来构建和捆绑 Rust 库。例如
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/318#issuecomment-1038751426">本评论</a>
是在 ARM Linux 上使用 Flutter。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="其他平台"><a class="header" href="#其他平台">其他平台</a></h1>
<p>对于所有剩下的平台，基本没有需要设置的步骤。除了在下面列表中标注的。<a href="https://docs.flutter.dev/desktop">Desktop support for Flutter</a>。如果你要查看当前进展，运行
<code>flutter -v</code> 它会显示你的工具链的状态和任何可操作的步骤。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模板之旅"><a class="header" href="#模板之旅">模板之旅</a></h1>
<p><img src="template/success.png" alt="success-screen" /></p>
<p>祝贺！🎉 现在你应该有一个可以正常运行的 Flutter 应用了，并且配备了 一个 Rust 运行时组件。本节旨在温和地介绍 Rust 与现有 Flutter
工具链集成的细节。不用担心，你可以直接跳到<a href="template/generate.html">生成代码</a>一节来学习如何编写新的代码。或者直接查看
<a href="template/../integrate.html">集成到现有项目</a> 一节，将 Rust 添加到现有的 Flutter 项目</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nativesrcapirs"><a class="header" href="#nativesrcapirs"><code>native/src/api.rs</code></a></h1>
<p>这是库默认入口文件，只有定义在这里的函数才能进行代码生成。函数可以引用定义在其他文件中的类型，作为参数或者返回值类型。但是这些类型必须通过 <code>pub use</code>
导入，以便它们在 <code>native/src/bridge_generated.rs</code> 中可见。</p>
<p>只有定义在当前 crate 的类型有资格进行代码生成。</p>
<p>除此之外，结构和枚举的字段也需要符合上述条件。</p>
<p>要查看目前符合条件的函数和类型，请看
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/rust/src/api.rs">示例文件</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="androidappbuildgradle"><a class="header" href="#androidappbuildgradle"><code>android/app/build.gradle</code></a></h1>
<p>该文件是 Flutter 构建安卓 app 所需默认文件的一部分。</p>
<p>模板中注入了额外的钩子，以便在调用 <code>flutter run</code> 时运行
<a href="https://lib.rs/crates/cargo-ndk"><code>cargo-ndk</code></a>。这个方法在以下文章中有更详细的解释
<a href="template/.../integrate/android_tasks.html">Hooking onto tasks</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nativenativexcodeproj"><a class="header" href="#nativenativexcodeproj"><code>native/native.xcodeproj</code></a></h1>
<p>这是由 <a href="https://lib.rs/crates/cargo-xcode"><code>cargo-xcode</code></a> 生成的 Xcode 项目文件夹，用于生成 Rust
代码库。</p>
<p>iOS 和 MacOS 的根项目会把这个文件夹作为 <em>子项目</em> 导入，并在 build 时依赖它。</p>
<p>为你的目标设备配置合适的 <code>cate-type</code> 非常重要。确保你的 <code>Cargo.toml</code> 中有这几行：</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;lib&quot;, &quot;cdylib&quot;, &quot;staticlib&quot;]
</code></pre>
<p>一些说明：</p>
<ul>
<li><code>lib</code> 对于非库项目时必须的，例如 tests 和 benchmarks</li>
<li><code>staticlib</code> 对 iOS 是必须的</li>
<li><code>cdylib</code> 是用于其他平台</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="justfile"><a class="header" href="#justfile"><code>justfile</code></a></h1>
<p>这个文件定义了 <a href="https://github.com/casey/just">just</a> 命令的 &quot;配方&quot;，它和 <code>make</code> 与 MakeFile 类似。<a href="https://github.com/casey/just">just</a> 使用 Rust 构建，并在传统的
Makefile 语法基础上做了改进，更好地支持条件语句、参数、跨平台兼容性等。</p>
<p>在某些设置中，通过 <code>brew install llvm</code> 安装不会使 LLVM 库对其他可执行文件可见，这会给 <code>ffigen</code> 带来了问题。
<code>flutter_rust_bridge_codegen</code> 使用它作为 C-to-Dart 的代码生成器。</p>
<p>运行 <code>just</code> 默认会运行 <code>gen</code> 和 <code>lint</code> 任务。</p>
<h2 id="just-gen"><a class="header" href="#just-gen"><code>just gen</code></a></h2>
<p>生成 Rust 绑定并把它们放到正确的文件夹。<a href="template/generate.html">Generating new code</a>
这部分会详细介绍如何修改任务脚本以执行附加任务。</p>
<h2 id="just-lint"><a class="header" href="#just-lint"><code>just lint</code></a></h2>
<p>运行 Dart 和 Rust 默认的 linter。</p>
<h2 id="just-clean"><a class="header" href="#just-clean"><code>just clean</code></a></h2>
<p>运行 Flutter 和 Rust 默认的 clean 命令。通常在调试和 build 相关的问题时有用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustcmake"><a class="header" href="#rustcmake"><code>rust.cmake</code></a></h1>
<p>在 <code>windows</code> 和 <code>linux</code> 中有两个相同的文件，名为<code>rust.cmake</code>。
这些文件包含在现有的<code>CMakeLists.txt</code>中，Flutter 使用它来编译对应平台的应用程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码生成"><a class="header" href="#代码生成">代码生成</a></h1>
<p>这一部分需要您已经跟随 <a href="template/template.html">创建一个新项目</a> 章节，并成功运行 <code>flutter run</code> 到您的设备上。</p>
<p>到目前为止，程序运行的所有必要代码都已经提供，没有额外的东西需要安装。现在我们将注意力集中在如何编写 Rust 代码，生成必要的胶水代码并在 Dart 中使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装代码生成器"><a class="header" href="#安装代码生成器">安装代码生成器</a></h1>
<p>更多信息在 <a href="template/../integrate/deps.html">安装依赖</a> 部分。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="添加新代码"><a class="header" href="#添加新代码">添加新代码</a></h1>
<p>我们想要跨平台，并不关心代码到底是在 Inter 还是 Apple Silicon
上运行。但是我们需要保留平台信息，以便底层代码能够作出对应的响应。我们可以把 <code>MacApple</code> 和 <code>MacIntel</code> 归为一个
<code>MacOs(String)</code>，里面包含了当前 CPU 架构。现在更新 <code>native/src/api.rs</code>:</p>
<pre><code class="language-diff"> pub enum Platform {
     ..
-    MacIntel,
-    MacApple,
+    MacOs(String),
     ..
 }
</code></pre>
<p>接着运行 <code>just</code>，看看生成的绑定代码会如何变化。</p>
<h2 id="troubleshooting-please-supply-one-or-more-pathtollvm"><a class="header" href="#troubleshooting-please-supply-one-or-more-pathtollvm">Troubleshooting: &quot;Please supply one or more path/to/llvm...&quot;</a></h2>
<p>对 LLVM 安装的检测在不同平台上并不可靠。特别是对于 MacOS 和 x86-64 和 arm64 的二进制文件，你可能需要修改 <code>justfile</code>
以明确指向它的位置：</p>
<pre><code>llvm_path := if os() == &quot;macos&quot; {
    &quot;--llvm-path /opt/homebrew/opt/llvm&quot;
} else {
    &quot;&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-build_runner"><a class="header" href="#使用-build_runner">使用 <code>build_runner</code></a></h1>
<p>检查一下你的 <code>lib/bridge_generated.dart</code>，你会发现 <code>Platform</code> 的定义变为了：</p>
<pre><code class="language-dart">@freezed
class Platform with _$Platform {
    const factory Platform.unknown() = Unknown;
    const factory Platform.android() = Android;
    const factory Platforn.ios() = Ios;
    const factory Platform.windows() = Windows;
    const factory Platform.unix() = Unix;
    const factory Platform.macOs(
        String field0,
    ) = MacOs;
    const factory Platform.wasm() = Wasm;
}
</code></pre>
<p>它不再是一个普通的枚举，而是带着一个具有变体的枚举类！现在代码不能通过编译，因为我们还缺少 <a href="https://pub.dev/packages/freezed"><code>freezed</code></a> 库。<a href="https://pub.dev/packages/freezed"><code>freezed</code></a>
库也是一个代码生成库，和我们目前为止遇到的有些相似，但是它生成的更多是 Dart 代码。所有的这些库都是在调用 <code>build_runner</code>
时进行代码生成的，即执行 <code>flutter pub run build_runner build</code> 时。</p>
<p>不管怎么说，为了使这段代码通过编译，我们需要做一些修改：</p>
<ul>
<li>执行下面的代码，添加最新的 <a href="https://pub.dev/packages/freezed"><code>freezed</code></a> 依赖：</li>
</ul>
<pre><code class="language-shell">flutter pub add -d build_runner
flutter pub add -d freezed
flutter pub add freezed_annotation
</code></pre>
<ul>
<li>更新 <code>justfile</code> 文件，在 Rust 代码生成后运行 <code>build_runner</code>:</li>
</ul>
<pre><code class="language-diff"> gen:
     ..
     # Uncomment this line to invoke build_runner as well
-    # flutter pub run build_runner build
+    flutter pub run build_runner build
</code></pre>
<p>现在调用 <code>just</code> 会同时生成 Rust 绑定和 Dart 代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="收尾"><a class="header" href="#收尾">收尾</a></h1>
<p>有了对 &quot;平台&quot; 的新定义，我们可以重写以前的代码去使用它！下面是一个例子，展示了 freezed 枚举的使用技巧。</p>
<p>在 <code>lib/main.dart</code> 里：</p>
<pre><code class="language-diff">- final text = const {
-   Platform.Android: 'Android',
-   Platform.Ios: 'iOS',
-   Platform.MacApple: 'MacOS with Apple Silicon',
-   Platform.MacIntel: 'MacOS',
-   Platform.Windows: 'Windows',
-   Platform.Unix: 'Unix',
-   Platform.Wasm: 'the Web',
- }[platform] ??
- 'Unknown OS';
+ final text = platform.when(
+   android: () =&gt; 'Android',
+   ios: () =&gt; 'iOS',
+   macOs: (arch) =&gt; 'MacOS on $arch',
+   windows: () =&gt; 'Windows',
+   unix: () =&gt; 'Unix',
+   wasm: () =&gt; 'the Web',
+ );
</code></pre>
<p>在 <code>native/src/api.rs</code> 里：</p>
<pre><code class="language-diff">     } else if cfg!(target_os = &quot;ios&quot;) {
         Platform::Ios
     } else if cfg!(all(target_os = &quot;macos&quot;, target_arch = &quot;aarch64&quot;)) {
-        Platform::MacApple
+        Platform::MacOs(&quot;Apple Silicon&quot;.into())
     } else if cfg!(target_os = &quot;macos&quot;) {
-        Platform::MacIntel
+        Platform::MacOs(&quot;Intel&quot;.into())
     } else if cfg!(target_family = &quot;wasm&quot;) {
         Platform::Wasm
     } else if cfg!(unix) {
</code></pre>
<p>当你运行 <code>flutter run</code> 后，你应该能看到： <img src="template/macos_intel.png" alt="macos-intel" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集成到现有项目"><a class="header" href="#集成到现有项目">集成到现有项目</a></h1>
<p>这一部分是中级教程，介绍了如何将 Rust 与现有的 Flutter 项目集成。如果您是 Rust 初学者，或者只是在配置开发环境，我建议你先去看
<a href="template/tour.html">the template tour</a> 章节，学习 <code>flutter run</code> 背后的部分。</p>
<p>在进入教程之前，为了使集成更简单，请更新你的 Flutter SDK，如果可以的话，也请您重新构建项目。</p>
<p><strong>注意:</strong> 虽然过程很复杂，但是绝大多数原因都不是来源于该库本身，使用原始的 Rust/Flutter FFI 和它一样复杂。换句话说，真正耗时的是搭建
Dart / Flutter + Rust 工具链。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建一个新的-crate"><a class="header" href="#创建一个新的-crate">创建一个新的 crate</a></h1>
<p>首先，你需要在项目文件夹里创建一个新的 Rust crate，运行 <code>cargo new --lib</code>。建议将 crate
的根目录设为和其他项目同等级别，这样有助于简化配置过程。</p>
<pre><code>├── android
├── ios
├── lib
├── linux
├── macos
├── $crate
│   ├── Cargo.toml
│   └── src
├── test
├── web
└── windows
</code></pre>
<p>这部分中我们会把你的 crate 称为 <code>$crate</code>。除非有其他说明，crate 文件夹和 crate 名称意义相同。</p>
<p>接着，在你的 <code>Cargo.toml</code> 加上这两行：</p>
<pre><code class="language-diff">+[lib]
+crate-type = [&quot;staticlib&quot;, &quot;cdylib&quot;]
</code></pre>
<p>这两个行配置会让你的 crate 在 MacOS 和 iOS 上构建为一个静态库。在其他平台上则是动态库。根据你的需要进行配置。如果你
需要编写单元测试或基准测试，也可以把 <code>&quot;rlib&quot;</code> 加进去。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装依赖"><a class="header" href="#安装依赖">安装依赖</a></h1>
<p>下一步，我们需要安装一些构建时和运行时依赖。</p>
<h2 id="构建依赖"><a class="header" href="#构建依赖">构建依赖</a></h2>
<p>这些依赖只在 build 时需要：</p>
<ul>
<li><a href="https://lib.rs/crates/flutter_rust_bridge_codegen"><code>flutter_rust_bridge_codegen</code></a>,
生成 Rust-Dart 胶水代码的核心</li>
<li><a href="https://pub.dev/packages/ffigen"><code>ffigen</code></a>, 从 C 头文件中生成 Dart 代码</li>
<li>安装 LLVM, 请看
<a href="https://pub.dev/packages/ffigen#installing-llvm">Installing LLVM</a>, <code>ffigen</code>
会使用到</li>
<li>(可选) <a href="https://lib.rs/crates/cargo-xcode"><code>cargo-xcode</code></a>,如果你想生成为 IOS 和 MacOS 的
Xcode 项目</li>
</ul>
<p>安装这些依赖的简单方法：</p>
<ul>
<li>
<p>dart 项目</p>
<pre><code class="language-bash">cargo install flutter_rust_bridge_codegen
dart pub add --dev ffigen &amp;&amp; dart pub add ffi
# if building for iOS or MacOS
cargo install cargo-xcode
</code></pre>
</li>
<li>
<p>flutter 项目</p>
<pre><code class="language-bash">cargo install flutter_rust_bridge_codegen
flutter pub add --dev ffigen &amp;&amp; flutter pub add ffi
# if building for iOS or MacOS
cargo install cargo-xcode
</code></pre>
</li>
</ul>
<p>另外，这些依赖也可能已经提供了预构建的二进制版本。请自行到包管理器中查找。</p>
<h2 id="dart-依赖"><a class="header" href="#dart-依赖">Dart 依赖</a></h2>
<p>在 Dart 这里，<code>flutter_rust_bridge</code> 是 <code>flutter_rust_bridge_codegen</code> 必需的运行时组件。如果你打算在
Dart 中使用 Rust 的 enum struct，你需要这些依赖：</p>
<ul>
<li><code>build_runner</code> (dev)</li>
<li><code>freezed</code> (dev)</li>
<li><code>freezed_annotation</code></li>
</ul>
<p>它们的是使用方法在 <a href="integrate/../generate/build_runner.html">Using <code>build_runner</code></a>。</p>
<pre><code class="language-bash">flutter pub add flutter_rust_bridge
# if using Dart codegen
flutter pub add -d build_runner
flutter pub add -d freezed
flutter pub add freezed_annotation
</code></pre>
<h2 id="rust-依赖"><a class="header" href="#rust-依赖">Rust 依赖</a></h2>
<p>和 Dart 类似，Rust 需要 <code>flutter_rust_bridge</code> 最为运行时依赖。</p>
<p>在 <code>Cargo.toml</code> 里添加：</p>
<pre><code class="language-diff">+[dependencies]
+flutter_rust_bridge = &quot;1&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集成到安卓"><a class="header" href="#集成到安卓">集成到安卓</a></h1>
<p>设置过程与 <a href="integrate/../template/setup_android.html">Android setup</a> 相同。
所以请继续按照那里的步骤进行。当你完成后，我们将继续修改现有的工具链以适应 Rust。</p>
<p>设置 Cargo 与 Gradle 一起运行的方法有很多，本指南将介绍两种主要方式：任务钩子（hooking onto tasks），以及与 CMake 集成。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooking-onto-tasks"><a class="header" href="#hooking-onto-tasks">Hooking onto tasks</a></h1>
<p>这部分与模板的使用方法相同，也是比较简单的方法。如果你还没有安装 <code>cargo-ndk</code>，请继续安装。</p>
<pre><code>cargo install cargo-ndk
</code></pre>
<p>接着，在 <code>android/app/build.gradle</code> 的最后添加下面几行：</p>
<pre><code class="language-gradle">[
    new Tuple2('Debug', ''),
    new Tuple2('Profile', '--release'),
    new Tuple2('Release', '--release')
].each {
    def taskPostfix = it.first
    def profileMode = it.second
    tasks.whenTaskAdded { task -&gt;
        if (task.name == &quot;javaPreCompile$taskPostfix&quot;) {
            task.dependsOn &quot;cargoBuild$taskPostfix&quot;
        }
    }
    tasks.register(&quot;cargoBuild$taskPostfix&quot;, Exec) {
        // Until https://github.com/bbqsrc/cargo-ndk/pull/13 is merged,
        // this workaround is necessary.

        def ndk_command = &quot;&quot;&quot;cargo ndk \
            -t armeabi-v7a -t arm64-v8a -t x86_64 -t x86 \
            -o ../android/app/src/main/jniLibs build $profileMode&quot;&quot;&quot;

        workingDir &quot;../../$crate&quot;
        environment &quot;ANDROID_NDK_HOME&quot;, &quot;$ANDROID_NDK&quot;
        if (org.gradle.nativeplatform.platform.internal.DefaultNativePlatform.currentOperatingSystem.isWindows()) {
            commandLine 'cmd', '/C', ndk_command
        } else {
            commandLine 'sh', '-c', ndk_command
        }
    }
}
</code></pre>
<p>注意 ANDROID_NDK 变量，这是一个 Gradle 属性，它指向你安装的 Android NDK 目录。你可以硬编码这个值，但最可靠的方法是写入到
<code>~/.gradle/gradle.properties</code>：</p>
<pre><code>ANDROID_NDK=(path to NDK)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmake-和-gradle"><a class="header" href="#cmake-和-gradle">CMake 和 Gradle</a></h1>
<p>如果你之前看过 <em>windows</em> 或 <em>linux</em> 文件夹，你会看到 一个名为 <em>CMakeLists.txt</em> 的文件。这个文件是 CMake
工具链的定义文件，Flutter 使用它来构建 Windows 和 Linux 应用程序。你也可以在 Gradle 上使用
这个策略，但这种设置超出了本指南的范围，是留给高级人员的。</p>
<p>请参考官方 Android 文档中的
<a href="https://developer.android.com/studio/projects/add-native-code">Add C and C++ code to your project</a>，围绕
C 语言的特定部分进行修改，并使用 <a href="https://github.com/corrosion-rs/corrosion"><code>Corrosion</code></a>
这样的工具来集成到 Cargo。这种设置的好处是，你可以重复使用 C 语言工具，并且受益于各种现有成熟技术，如构建缓存。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="与-iosmacos-集成"><a class="header" href="#与-iosmacos-集成">与 iOS/MacOS 集成</a></h1>
<p><em>Credit to
<a href="https://github.com/brotskydotcom/rust-on-ios">brotskydotcom/rust-on-ios</a> for
the inspiration of this method.</em></p>
<p>为 iOS 和 MacOS 设置 <code>flutter run</code> 比其他平台稍微复杂一些。由于其对 Xcode 用户界面的依赖。本指南假设您正在运行
一个相对较新的 Xcode 版本，在写这篇文章的时候是 Xcode 13。其他版本可能会有一些小的差异，但整体过程应该是相同的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建-rust-项目"><a class="header" href="#创建-rust-项目">创建 Rust 项目</a></h1>
<p>首先，请按照 <a href="https://gitlab.com/kornelski/cargo-xcode#usage">Usage</a> 中 <code>cargo-xcode</code>
部分的说明进行操作。下面的内容就是从那里引用的，但请注意，它可能已经过时了。</p>
<hr />
<p>确保你的 <code>$crate/Cargo.toml</code> 里有下面几行代码：</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;lib&quot;, &quot;staticlib&quot;, &quot;cdylib&quot;]
</code></pre>
<p>一些说明</p>
<ul>
<li><code>lib</code> 对于非库项目时必须的，例如 tests 和 benchmarks</li>
<li><code>staticlib</code> 对 iOS 是必须的</li>
<li><code>cdylib</code> 是用于其他平台</li>
</ul>
<p>请按照您的需求进行配置。接着在 <code>$crate</code> 下运行：</p>
<pre><code class="language-bash">cargo xcode
</code></pre>
<p>这行命令会生成一个 <code>$crate/$crate.xcodeproj</code>，可以导入到其他 Xcode 项目。你只需要为每个 crate
做一次这样的工作。先不要打开这个项目 我们需要先通过父项目对其进行配置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="链接该项目"><a class="header" href="#链接该项目">链接该项目</a></h1>
<p>在 Xcode 中打开 <code>ios/Runner.xcodeproj</code>, 接着把 <code>$crate/$crate.xcodeproj</code>
添加为子项目。结果大致是这样：</p>
<p><img src="integrate/ios_proj_tree.png" alt="proj-tree" /></p>
<p>点击 <code>Runner</code> 根项目，接着找到 <strong>Build Phases</strong>. 首先，展开 <strong>Dependencies</strong> , 接着对于 IOS 请添加
<strong>$crate-staticlib</strong> ，对于 MacOS 请添加 <strong>$crate-cdylib</strong> 。</p>
<p><img src="integrate/ios_dep_phase.png" alt="dep-phase" /></p>
<p>接着，展开 <strong>Link Binary With Libraries</strong>, 为 IOS 添加 <strong>lib$crate_static.a</strong>，或者对于 MacOS
添加 <strong>$crate.dylib</strong>.</p>
<p><img src="integrate/ios_link_phase.png" alt="link-phase" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生成绑定"><a class="header" href="#生成绑定">生成绑定</a></h1>
<p>现在我们已经完成了大部分的工作，让我们来编译我们的 Rust 程序。如果你刚才创建了你的 crate，请继续 在 <em>$crate/src/api.rs</em>
处添加一个新文件，并将其内容替换为下面的代码片段或其他内容。</p>
<pre><code class="language-rust ignore">pub fn greet() -&gt; String {
    &quot;Hello from Rust! 🦀&quot;.into()
}
</code></pre>
<p>接着在 <code>$crate/src/lib.rs</code> 添加：</p>
<pre><code class="language-diff">+mod api;
</code></pre>
<h2 id="运行代码生成"><a class="header" href="#运行代码生成">运行代码生成</a></h2>
<p>在我们编译之前，我们需要先生成绑定。从项目根目录运行这些命令：</p>
<pre><code class="language-bash">flutter_rust_bridge_codegen \
    -r $crate/src/api.rs \
    -d lib/bridge_generated.dart \
    -c ios/Runner/bridge_generated.h \
    -c macos/Runner/bridge_generated.h   # if building for MacOS
</code></pre>
<blockquote>
<p><strong>注意：</strong> 每次修改 Rust 代码后都会使用到这些命令。</p>
</blockquote>
<p>运行这个命令可以得到由 Rust 库导出的函数和类型的 C 头文件。我们需要确保它来保持符号不被剥离。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-dummy-headers"><a class="header" href="#using-dummy-headers">Using dummy headers</a></h1>
<p><code>flutter_rust_bridge_codegen</code> 会创建一个 C 头文件，里面列出了 Rust 库导出的所有符号，我们需要使用它确保 Xcode
不会将符号去除。</p>
<p>在项目中添加 <code>ios/Runner/bridge_generated.h</code> (或者
<code>macos/Runner/bridge_generated.h</code>)，你可以把文件直接拖到项目文件夹中或者点击菜单上的 <strong>Add Files to
&quot;Runner&quot;...</strong> .</p>
<p>如果它还没有出现，请切换到 <strong>Build Phases</strong> 标签页，把 <strong>bridge_generated.h</strong> 文件拖到 <strong>Copy Bundle
Resources</strong>。</p>
<h2 id="ios"><a class="header" href="#ios">iOS</a></h2>
<p>接下来，在 <code>ios/Runner/Runner-Bridging-Header.h</code> 中添加：</p>
<pre><code class="language-diff">+#import &quot;bridge_generated.h&quot;
</code></pre>
<p>在 <code>ios/Runner/AppDelegate.swift</code> 中添加：</p>
<pre><code class="language-diff"> override func application(
     _ application: UIApplication,
     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
 ) -&gt; Bool {
+    let dummy = dummy_method_to_enforce_bundling()
+    print(dummy)
     ..
 }
</code></pre>
<p>这里调用 <code>dummy_method_to_enforce_bundling()</code>
并打印返回值的步骤非常重要（类似于上面的例子），否则最终的符号还是可能被去除。</p>
<h2 id="macos"><a class="header" href="#macos">MacOS</a></h2>
<p>Flutter 在 MacOS 上默认不使用符号，我们需要添加我们自己的。在 <strong>Build Settings</strong> 标签页中，把 <strong>Objective-C
Bridging Header</strong> 设置为 <strong>Runner/bridge_generated.h</strong></p>
<p>最后，在 <code>macos/Runner/AppDelegate.swift</code> 文件的某个地方使用一下
<code>dummy_method_to_enforce_bundling</code> , 只要 Xcode 不把它当作 dead code 就行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="与-windows-和-linux-集成"><a class="header" href="#与-windows-和-linux-集成">与 Windows 和 Linux 集成</a></h1>
<p>本指南将 Windows 和 Linux 桌面应用程序的说明放在一起，因为它们使用相同的构建系统。</p>
<p>和其他平台一样：我们将使用脚本整合到现有的项目。现在我们将借用下模板，把
<a href="https://raw.githubusercontent.com/Desdaemon/flutter_rust_bridge_template/main/windows/rust.cmake">rust.cmake</a>
下载到你的 &quot;windows&quot; 和 &quot;linux&quot; 文件夹里。请注意，CMake
会拒绝使用位于其工作目录之外的文件，所以在这两个文件夹之间会有一些重复的文件。</p>
<p>接下来，在你的<code>CMakeLists.txt</code>文件中添加这一行：</p>
<pre><code class="language-diff"> # Generated plugin build rules, which manage building the plugins and adding
 # them to the application.
 include(flutter/generated_plugins.cmake)

+include(./rust.cmake)

 # === Installation ===
 # Support files are copied into place next to the executable, so that it can
</code></pre>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<p>在 Linux 上，你需要将 CMake 的最低版本升到 3.12，这是
<a href="https://github.com/corrosion-rs/corrosion">Corrosion</a> 的要求，<code>rust.cmake</code> 依赖
Corrosion。请修改 <code>linux/CMakeLists.txt</code> 的这一行：</p>
<pre><code class="language-diff">-cmake_minimum_required(VERSION 3.10)
+cmake_minimum_required(VERSION 3.12)
</code></pre>
<p>可选：你可以将 Corrosion 安装到系统上。请查看
<a href="integrate/../template/setup_desktop.html">Linux troubleshooting notes</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="与-web-集成"><a class="header" href="#与-web-集成">与 Web 集成</a></h1>
<p>截至发稿时，Web
支持正在进行中，并在<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/315">fzyzcjy/flutter_rust_bridge#315</a>持续跟踪。
请留下评论和建议，让我们了解您对这一功能的需求！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用动态连接库"><a class="header" href="#使用动态连接库">使用动态连接库</a></h1>
<p>如果一切顺利，运行 <code>flutter run</code> 就会自动构建你的 Rust 库，Flutter 二进制文件，并将二者连接起来。现在唯一要做的事情就是使用它！</p>
<p>把
<a href="https://raw.githubusercontent.com/Desdaemon/flutter_rust_bridge_template/main/lib/ffi.dart">这个文件</a>
下载到 <code>lib/ffi.dart</code>,接着修改下面几行：</p>
<pre><code class="language-diff"> // Re-export the bridge so it is only necessary to import this file.
 export 'bridge_generated.dart';
 import 'dart:io' as io;

-const _base = 'native';
+const _base = '$crate';

 // On MacOS, the dynamic library is not bundled with the binary,
 // but rather directly **linked** against the binary.
 final _dylib = io.Platform.isWindows ? '$_base.dll' : 'lib$_base.so';
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="收尾工作"><a class="header" href="#收尾工作">收尾工作</a></h1>
<p>恭喜！您已经成功地将 Rust 组件通过 <code>flutter_rust_bridge</code> 添加到您的 Flutter 程序中，并配置了
<code>flutter run</code> 来构建您的 Rust 库并将其链接到程序中。</p>
<p>作为提醒，每次 Rust 代码改变时，以及在你运行<code>flutter run</code>之前，你都需要运行这些命令。</p>
<pre><code class="language-bash">flutter_rust_bridge_codegen \
    -r $crate/src/api.rs \
    -d lib/bridge_generated.dart \
    -c ios/Runner/bridge_generated.h \
    -c macos/Runner/bridge_generated.h   # if building for MacOS
# if using Dart codegen
flutter pub run build_runner build
</code></pre>
<h2 id="重命名-rust-bridge-模块"><a class="header" href="#重命名-rust-bridge-模块">重命名 Rust bridge 模块</a></h2>
<p>如果你想用 <code>flutter_rust_bridge_codegen</code> 的 <code>--rust-output</code> 参数，不要忘记更新
<code>$crate/src/lib.rs</code> 里引用的模块名</p>
<pre><code class="language-bash">flutter_rust_bridge_codegen \
    ..
    --rust-output $crate/src/my_bridge.rs
</code></pre>
<p>then you need to modify this in <code>lib.rs</code>:</p>
<pre><code class="language-diff">-mod bridge_generated;
+mod my_bridge;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="总览"><a class="header" href="#总览">总览</a></h1>
<h2 id="prelude"><a class="header" href="#prelude">Prelude</a></h2>
<p>首先，欢迎并感谢您做出的贡献！</p>
<p>如果你想成为一个贡献者，请提交一个
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/pulls">Pull Request</a>。如果你需要一些改进的点子，去看一下仓库的
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues">Issues section</a></p>
<p>需要一个 PR 模板？请看一下
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/PULL_REQUEST_TEMPLATE.md">PR template</a>.</p>
<h2 id="总体设计"><a class="header" href="#总体设计">总体设计</a></h2>
<p>如果你想从高层了解这个库的实现原理，这里是整体设计：<a href="contributing/design.html">link</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计总览"><a class="header" href="#设计总览">设计总览</a></h1>
<blockquote>
<p>这篇文档正在编写中。Tracking issue:
https://github.com/fzyzcjy/flutter_rust_bridge/issues/593</p>
</blockquote>
<h2 id="文件结构"><a class="header" href="#文件结构">文件结构</a></h2>
<ul>
<li><code>frb_codegen</code>: 代码生成器。它接收 <code>api.rs</code> 作为输入，并输出 Rust and Dart 代码文件。</li>
<li><code>frb_example</code>: 例子。
<ul>
<li><code>pure_dart</code>: 不只是一个例子，更重要的是作为端到端的测试。</li>
<li><code>with_flutter</code>: 集成到 Flutter 的例子。</li>
<li><code>pure_dart_multi</code>: 展示多文件的使用。</li>
</ul>
</li>
<li><code>frb_dart</code>: 对 Dart 库的支持 - 需要由用户引入。</li>
<li><code>frb_rust</code>: 对 Rust 库的支持 - 需要由用户引入。</li>
<li><code>frb_macros</code>: <code>frb_rust</code> 独立的一部分。<small> 由于 proc macro 的限制，所以它是一个独立的
crate。</small></li>
<li><code>book</code>: 文档。</li>
<li><code>.github</code>: GitHub 相关。
<ul>
<li><code>workflows/ci.yaml</code>: CI 工作流的定义。</li>
</ul>
</li>
</ul>
<h2 id="代码生成结构"><a class="header" href="#代码生成结构">代码生成结构</a></h2>
<p>流程如下：</p>
<pre><code>----------    src/parser    ----------    src/generator     ---------------
| api.rs | ---------------&gt; | src/ir | -------------------&gt; | Rust &amp; Dart |
----------                  ----------                      ---------------
</code></pre>
<ul>
<li>输入 (即图中的 <code>api.rs</code>), 是由用户提供的手工编写的 Rust 代码。</li>
<li>解析器 (<code>src/parser</code>) 将输入的代码 (其实是 <a href="https://crates.io/crates/syn">syn</a> 树) 转换为 IR.</li>
<li>IR (<code>src/ir</code>), 或者说 internal representation, 是一种结构，用来表示我们感兴趣的代码的信息。</li>
<li>生成器 (<code>src/generator</code>) 将 IR 转换为最终的输出。更具体一点就是 <code>src/generator/dart</code> 生成 Dart 代码，
<code>src/generator/rust</code> 生成 Rust 代码，<code>src/generator/c</code> 生成 (部分) C 代码。</li>
<li>最终的输出 (图中的 <code>Rust &amp; Dart</code>) 被写入到对应的文件。</li>
</ul>
<h2 id="数据流"><a class="header" href="#数据流">数据流</a></h2>
<blockquote>
<p>建议读者配合着 IDE 的代码跳转功能一同查看</p>
</blockquote>
<p>让我们看一下当调用一个函数时发生了什么。</p>
<p>假设用户调用了一个（生成的）名为 <code>func</code> 的 Dart 函数 <code>func({required String str})</code>。下面是详细的调用过程：</p>
<ol>
<li>生成的 Dart 函数，<code>func({required String str})</code>, 首先会将参数类型进行转换，将 &quot;<em>Dart api data</em>&quot;
(即用户提供的数据) 转换为 &quot;<em>Dart wire data</em>&quot; (即真正在 Dart 和 Rust 间传递的数据)。再具体一点，它会调用
<code>_api2wire_String(str)</code> 并得到一个指针 <code>ffi.Pointer&lt;wire_uint_8_list&gt;</code> (因为 <code>String</code>
类型在底层使用 <code>pub struct wire_uint_8_list { ptr: *mut u8, len: i32 }</code>) 表示。</li>
<li>接着可以用拿到的底层数据结构 <code>wire_uint_8_list</code> 调用 Dart 版本的 <code>wire_func</code>。在此之前，我们已经使用代码生成器生成了
Rust 的 <code>wire_func</code> 函数，并使用 <code>cbindgen</code> 生成对应的 C 函数，使用 <code>ffigen</code> 得到对应的 Dart
函数。在这里，我们调用 Dart 版本的 <code>wire_func</code>。注意，因为我们使用的是和 C
语言兼容的函数，所以我们只能传递类似于指针的低级数据类型，而不是高级的安全的数据类型。</li>
<li>当 Rust 版的 <code>wire_func</code> 被调用时，也会对参数类型进行转换。即使用 <code>.wire2api()</code> 将 &quot;<em>Rust wire data</em>&quot;
(<code>wire_uint_8_list</code>，在 Dart 和 Rust 间传递的数据) 转换为 &quot;<em>Rust api data</em>&quot; (在这里就是
<code>String</code>, 用户真正使用的数据).</li>
<li>携带着转换后的 &quot;<em>Rust api data</em>&quot; 调用 <code>FLUTTER_RUST_BRIDGE_HANDLER</code>。handler
是用户自定义的，所以用户可以提供他们自己的实现，而不是使用默认的线程池等。默认情况下，我们的 Handler 使用一个线程池，并在里面调用
<code>api.rs</code> 中定义的由用户编写的 Rust 函数</li>
<li>调用用户编写的 <code>fn func(str: String) -&gt; String { ... }</code>，并得到返回值。</li>
<li>返回值类型是一个 <code>String</code>，它会被传递到 Dart 侧。这是通过 Dart 提供的 API
实现的。<a href="https://github.com/dart-lang/sdk/blob/fd0d3b254690007d0ebc84175f30fa7d7491ec3e/runtime/include/dart_native_api.h#L124"><code>Dart_PostCObject</code></a>，这个项目允许我们提供
C 的结构体，并自动转换到 Dart 的数据。我们使用了一个 Rust 安全的 wrapper <code>allo-isolate</code> 去通信，因为它允许 Dart
代码可以是异步的而不是同步。</li>
<li>现在让我们回到 Dart 一侧，你应该会接收到一些 Dart 对象（其实就是 &quot;<em>Dart wire data</em>&quot;）。接着我们会使用一些类似于
<code>_wire2api_SomeType</code> 的函数将它们转换为最终的 &quot;<em>Dart api data</em>&quot;。注意，这里提到的 &quot;wire2api&quot; 只定义在
Dart 一侧，它的作用就是将 &quot;<em>Dart</em> wire data&quot; 转换为 &quot;<em>Dart</em> api data&quot;，和之前定义在 Rust
中的不一样。举个例子，由于 <code>Dart_PostCObject</code> 并没有提供构建任意的结构体（类）的方法，我们必须将 Rust
结构体中的所有字段作为一个列表传递，并使用 <code>wire2api</code> 转换为对应的 Dart 类。</li>
<li>最终的结果会以 Dart 函数的返回值出现，即用户刚开始调用的 <code>func</code> 函数。到此为止，函数调用的整个过程就结束了！</li>
</ol>
<h2 id="内存安全"><a class="header" href="#内存安全">内存安全</a></h2>
<p>如何保障内存安全？这个具体需要具体问题具体分析。例如，假设我们想看一个 <code>String</code> 是如何从 Dart 传递给 Rust 的。那么我们需要关注的是
Dart 的 <code>_api2wire_String</code> 和 Rust 的 <code>.wire2api()</code>。</p>
<p>实际上 <code>String</code> 是通过委派给 <code>Vec&lt;u8&gt;</code> 生成的，所以我们需要检查和 String 和 <code>Vec&lt;u8&gt;</code> 相关
的代码。经过一系列跳转，你会看到下面的代码：</p>
<pre><code class="language-dart">ffi.Pointer&lt;wire_uint_8_list&gt; _api2wire_String(String raw) {
  return _api2wire_uint_8_list(utf8.encoder.convert(raw));
}

ffi.Pointer&lt;wire_uint_8_list&gt; _api2wire_uint_8_list(Uint8List raw) {
  final ans = inner.new_uint_8_list_0(raw.length);
  ans.ref.ptr.asTypedList(raw.length).setAll(0, raw);
  return ans;
}
</code></pre>
<p>以及</p>
<pre><code class="language-rust noplayground">impl Wire2Api&lt;Vec&lt;u8&gt;&gt; for *mut wire_uint_8_list {
    fn wire2api(self) -&gt; Vec&lt;u8&gt; {
        unsafe {
            let wrap = support::box_from_leak_ptr(self);
            support::vec_from_leak_ptr(wrap.ptr, wrap.len)
        }
    }
}

impl Wire2Api&lt;String&gt; for *mut wire_uint_8_list {
    fn wire2api(self) -&gt; String {
        let vec: Vec&lt;u8&gt; = self.wire2api();
        String::from_utf8_lossy(&amp;vec).into_owned()
    }
}

pub struct wire_uint_8_list {
    ptr: *mut u8,
    len: i32,
}
</code></pre>
<p>换句话说，String（或者 <code>Vec&lt;u8&gt;</code>）被转换为了一个原始结构体，它带有指针和长度字段。对内存的操作非常小心，因此不会造成泄漏或重复释放。</p>
<p>我们同时还使用了 Valgrind 进行检查，我本人已经在生产环境中使用它，并没有发现任何问题，所以不用担心内存问题。</p>
<h2 id="想了解更多请告诉我"><a class="header" href="#想了解更多请告诉我">想了解更多？请告诉我</a></h2>
<p>你还想了解哪些方面？请在 Github 上创建一个 Issue，我会告诉你更多 :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<blockquote>
<p>注意：一些文档可能过时了。请在 ci.yaml, 主文档，justfile 等等查看最新版本，etc to see an up-to-date
version. 本附录将进行大修。</p>
</blockquote>
<h2 id="发行新版本"><a class="header" href="#发行新版本">发行新版本</a></h2>
<p>通常是由库的拥有者做的 (@fzyzcjy),所以你基本不需要做这一步。如果你需要发布一个新版本，至少需要进行以下步骤。Bump 一些版本，在
changelog 中改变版本号，并使用 <code>cargo check</code>来自动更新实例的依赖版本。</p>
<pre><code>just release
</code></pre>
<h2 id="运行代码生成器的简单代码"><a class="header" href="#运行代码生成器的简单代码">运行代码生成器的简单代码</a></h2>
<p>只需要从
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/workflows/codegen.yml">CI codegen.yml</a>
复制即可。</p>
<pre><code>(cd frb_codegen &amp;&amp; cargo run --package flutter_rust_bridge_codegen --bin flutter_rust_bridge_codegen -- --rust-input ../frb_example/pure_dart/rust/src/api.rs --dart-output ../frb_example/pure_dart/dart/lib/bridge_generated.dart --dart-format-line-length 120 &amp;&amp; cargo run --package flutter_rust_bridge_codegen --bin flutter_rust_bridge_codegen -- --rust-input ../frb_example/with_flutter/rust/src/api.rs --dart-output ../frb_example/with_flutter/lib/bridge_generated.dart --c-output ../frb_example/with_flutter/ios/Runner/bridge_generated.h --dart-format-line-length 120)
</code></pre>
<h2 id="格式化-和-lint"><a class="header" href="#格式化-和-lint">格式化 和 lint</a></h2>
<pre><code>(cd frb_codegen &amp;&amp; cargo fmt --all); (cd frb_rust &amp;&amp; cargo fmt --all); (cd frb_macros &amp;&amp; cargo fmt --all); (cd frb_example/pure_dart/rust &amp;&amp; cargo fmt --all); (cd frb_example/with_flutter/rust &amp;&amp; cargo fmt --all);
(cd frb_codegen &amp;&amp; cargo clippy); (cd frb_rust &amp;&amp; cargo clippy); (cd frb_macros &amp;&amp; cargo clippy); (cd frb_example/pure_dart/rust &amp;&amp; cargo clippy); (cd frb_example/with_flutter/rust &amp;&amp; cargo clippy);
(cd frb_dart &amp;&amp; dart format . --line-length 80); (cd frb_example/pure_dart/dart &amp;&amp; dart format . --line-length 120); (cd frb_example/with_flutter &amp;&amp; dart format . --line-length 120);
(cd frb_dart &amp;&amp; dart analyze --fatal-infos); (cd frb_example/pure_dart/dart &amp;&amp; dart analyze --fatal-infos); (cd frb_example/with_flutter &amp;&amp; dart analyze --fatal-infos);
</code></pre>
<h2 id="升级依赖的版本"><a class="header" href="#升级依赖的版本">升级依赖的版本</a></h2>
<pre><code>flutter pub upgrade flutter_rust_bridge
cargo update -p flutter_rust_bridge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="教程pure-dart"><a class="header" href="#教程pure-dart">教程：Pure Dart</a></h1>
<p><strong>注意</strong>: 如果你想了解每一条具体命令，
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/workflows/test.yaml">CI workflow</a>
中的 <code>valgrind_test</code> 部分也是有用的。</p>
<p>和之前的教程不一样，这个教程里 Rust 只和 Dart 本身集成，没有 Flutter.</p>
<h2 id="拿到示例代码"><a class="header" href="#拿到示例代码">拿到示例代码</a></h2>
<p>请 <a href="https://dart.dev/get-dart">下载 Dart</a>,
<a href="https://www.rust-lang.org/learn/get-started">下载 Rust</a>,并熟悉一下。接着运行
<code>git clone https://github.com/fzyzcjy/flutter_rust_bridge</code>, 例子在
<code>frb_example/pure_dart</code>.</p>
<h2 id="可选-手动运行代码生成"><a class="header" href="#可选-手动运行代码生成">(可选) 手动运行代码生成</a></h2>
<p>注意：代码会在运行完 <code>cargo build</code> 后，通过 <em>build.rs</em>
里的构建脚本自动生成。所以这一步是可选的。即使你再次运行，代码也不会发生什么改变。</p>
<p>安装代码生成器：<code>cargo install flutter_rust_bridge_codegen</code>.</p>
<p>运行：
<code>flutter_rust_bridge_codegen --rust-input frb_example/pure_dart/rust/src/api.rs --dart-output frb_example/pure_dart/dart/lib/bridge_generated.dart</code>
(你可以将
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/workflows/codegen.yml">CI workflow</a>
最为查阅手册.) (对 Windows 用户，你可能需要在路径里用 <code>\\</code> 代替 <code>/</code>.)</p>
<h2 id="run-dartrust-app"><a class="header" href="#run-dartrust-app">Run &quot;Dart+Rust&quot; app</a></h2>
<p>你可以将 <code>frb_example/pure_dart/dart/lib/main.dart</code> 作为一个普通的 Dart 程序运行，唯一不同的是，你需要提供
Rust 的动态连接库 (简单起见，这里我只演示动态链接库的方法，但你当然可以使用其他方法）详细步骤如下。</p>
<p>在 <code>frb_example/pure_dart/rust</code> 目录下运行 <code>cargo build</code> 将 Rust 代码编译为 <code>.so</code> 文件。接着执行
<code>dart frb_example/pure_dart/dart/lib/main.dart frb_example/pure_dart/rust/target/debug/libflutter_rust_bridge_example.so</code>
去运行 Dart 程序。</p>
<p>(如果你的运行出现问题，请看 &quot;Troubleshooting&quot; 部分) (如果你的平台是 MacOS, Rust 应该会生成<code>.dylib</code>, 请把命令里的
<code>...dylib</code> 替换为 <code>...so</code>)</p>
<p>P.S. 这个例子里并没有 UI 或其他功能，你只能看到一些测试通过的信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全顾虑"><a class="header" href="#安全顾虑">安全顾虑</a></h1>
<p>该库使用 CI 工作流，并会在设置过程中自动运行 <a href="https://www.valgrind.org/">Valgrind</a> ，当 Dart 程序使用该库调用
Rust 程序时，Valgrind 能及时发现内存安全问题
<sub>( 注意：即时你只运行一个简单的 hello-world Dart 程序，Valgrind 也会检测到几百个错误。请查看
<a href="https://github.com/dart-lang/sdk/issues/47346">this Dart lang issue</a>
了解更多。因此，我检查了 Valgrind 报告的所有 &quot;definitely lost&quot;, 并且手动在库里搜索 -
如果报告的所有错误都和该库无关，那么它就是安全的)</sub></p>
<p>除此之外，与 Flutter 的集成也是通过 CI 完成。确保了使用该库的 Flutter 应用不会产生问题。</p>
<p>大多数代码都是 safe Rust。 <code>unsafe</code> 代码主要来自 <code>support::box_from_leak_ptr</code> 和
<code>support::vec_from_leak_ptr</code>. 他们被用于处理指针和数组，我会遵循高票数的答案和官方文档编写相关代码。</p>
<p>我在我的个人 Flutter 项目 (<code>yplusplus</code>, or <code>why++</code>) 里非常频繁的使用到了该库。那些 app
已经用于生产环境，并且运行非常稳定，如果我自己观察到了任何问题，我会修复相关 bug。</p>
<p>CI 同时会运行 <code>run_codegen</code> 工作流，确保生成的代码可以通过编译。最后，CI 还会运行代码格式化和 linter(<code>fmt</code>,
<code>clippy</code>, <code>dart analyze</code>, <code>dart format</code>), linter 也能捕获到一些常见错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<h2 id="the-generated-store_dart_post_cobject-has-the-wrong-signature--stdargh-file-not-found-in-linux--stdboolh--"><a class="header" href="#the-generated-store_dart_post_cobject-has-the-wrong-signature--stdargh-file-not-found-in-linux--stdboolh--">The generated store_dart_post_cobject() has the wrong signature / <code>'stdarg.h' file not found</code> in Linux / <code>stdbool.h</code> / ...</a></h2>
<p>Try to run code generator with working directory at <code>/</code>, or set the environment
variable:</p>
<pre><code class="language-bash">export CPATH=&quot;$(clang -v 2&gt;&amp;1 | grep &quot;Selected GCC installation&quot; | rev | cut -d' ' -f1 | rev)/include&quot;
</code></pre>
<p>as described in <a href="https://github.com/dart-lang/ffigen/issues/257">ffigen #257</a>,
or add include path as is described in
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/108">#108</a>. This is a
problem with Rust's builtin <code>Command</code>. See also:
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/472">#472</a> &amp;
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/494">#494</a>.</p>
<h2 id="issue-with-store_dart_post_cobject"><a class="header" href="#issue-with-store_dart_post_cobject">Issue with <code>store_dart_post_cobject</code></a></h2>
<p>If calling rust function gives the error below, please consider running <strong>cargo
build</strong> again. This can happen when the generated rs file is not included when
building is being done.</p>
<pre><code class="language-sh">[ERROR:flutter/lib/ui/ui_dart_state.cc(209)] Unhandled Exception: Invalid argument(s): Failed to lookup symbol 'store_dart_post_cobject': target/debug/libadder.so: undefined symbol: store_dart_post_cobject
</code></pre>
<h2 id="error-running-cargo-ndk-ld-error-unable-to-find-library--lgcc"><a class="header" href="#error-running-cargo-ndk-ld-error-unable-to-find-library--lgcc">Error running <code>cargo ndk</code>: <code>ld: error: unable to find library -lgcc</code></a></h2>
<p>Downgrade Android NDK to version 22. This is an
<a href="https://github.com/bbqsrc/cargo-ndk/issues/22">ongoing issue</a> with <code>cargo-ndk</code>,
a library unrelated to flutter_rust_bridge but solely used to build the
examples, when using Android NDK version 23. (See
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/149">#149</a>)</p>
<h2 id="fail-to-run-flutter_rust_bridge_codegen-on-macos-please-supply-one-or-more-pathtollvm"><a class="header" href="#fail-to-run-flutter_rust_bridge_codegen-on-macos-please-supply-one-or-more-pathtollvm">Fail to run <code>flutter_rust_bridge_codegen</code> on MacOS, &quot;Please supply one or more path/to/llvm...&quot;</a></h2>
<p>If you are running macOS, you will need to specify a path to your llvm:</p>
<pre><code class="language-shell">flutter_rust_bridge_codegen --rust-input path/to/your/api.rs --dart-output path/to/file/being/bridge_generated.dart --llvm-path /usr/local/homebrew/opt/llvm/
</code></pre>
<p>You can install llvm using <code>brew install llvm</code> and it will be installed at
<code>/usr/local/homebrew/opt/llvm/</code> by default.</p>
<h2 id="freezed-file-is-sometimes-not-generated-when-it-should-be"><a class="header" href="#freezed-file-is-sometimes-not-generated-when-it-should-be">Freezed file is sometimes not generated when it should be</a></h2>
<p>If your <code>.freezed.dart</code> or <code>.g.dart</code> seems outdated, ensure you have run the
<code>build_runner</code>.</p>
<p>Related: https://github.com/fzyzcjy/flutter_rust_bridge/issues/330</p>
<h2 id="cant-create-typedef-from-non-function-type"><a class="header" href="#cant-create-typedef-from-non-function-type"><code>Can't create typedef from non-function type.</code></a></h2>
<p>Ensure min sdk version of Flutter <code>pubspec.yaml</code> is at least 2.13.0 to let
<code>ffigen</code> happy.</p>
<p>https://github.com/fzyzcjy/flutter_rust_bridge/issues/334</p>
<h2 id="generated-code-is-so-long"><a class="header" href="#generated-code-is-so-long">Generated code is so long</a></h2>
<p>Indeed all generated code are necessary (if you find something that can be
simplified, file an issue). Moreover, other code generation tools also generate
long code - for example, when using Google protobuf, a very popular
serialization library, I see &gt;10k lines of Java code generated for a quite
simple source proto file.</p>
<h2 id="为什么需要-dart-2140"><a class="header" href="#为什么需要-dart-2140">为什么需要 Dart <code>2.14.0</code></a></h2>
<p>这个库并不需要 Dart SDK <code>&gt;=2.14.0</code>, 但是最新的 <code>ffigen</code> 工具需要。所以才会在 <code>pubspec.yaml</code> 的
<code>environment</code> 中限制 <code>sdk: &quot;&gt;=2.14.0 &lt;3.0.0&quot;</code>. 如果你需要摆脱这个限制，请考虑使用更老版本的 <code>ffigen</code> 工具。</p>
<h2 id="其它问题"><a class="header" href="#其它问题">其它问题？</a></h2>
<p>不要犹豫
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/new/choose">open an issue</a>!
我通常会在几分钟或者是几小时内回复 (当然除了我睡觉时 :D).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令行参数"><a class="header" href="#命令行参数">命令行参数</a></h1>
<p>加上 <code>--help</code> 查看完整文档。下面是一个快照 (可能已经过期):</p>
<pre><code class="language-shell">flutter_rust_bridge_codegen 1.20.1

USAGE:
    flutter_rust_bridge_codegen [FLAGS] [OPTIONS] --dart-output &lt;dart-output&gt; --rust-input &lt;rust-input&gt;

FLAGS:
        --skip-add-mod-to-lib    Skip automatically adding `mod bridge_generated;` to `lib.rs`
        --no-build-runner        Skip running build_runner even when codegen-capable code is detected
    -v, --verbose                Show debug messages
    -h, --help                   Prints help information
    -V, --version                Prints version information

OPTIONS:
    -r, --rust-input &lt;rust-input&gt;                              Path of input Rust code
    -d, --dart-output &lt;dart-output&gt;                            Path of output generated Dart code
        --dart-decl-output &lt;dart-decl-output&gt;
            If provided, generated Dart declaration code to this separate file

    -c, --c-output &lt;c-output&gt;...                               Path of output generated C header
        --rust-crate-dir &lt;rust-crate-dir&gt;                      Crate directory for your Rust project
        --rust-output &lt;rust-output&gt;                            Path of output generated Rust code
        --class-name &lt;class-name&gt;                              Generated class name
        --dart-format-line-length &lt;dart-format-line-length&gt;    Line length for dart formatting
        --llvm-path &lt;llvm-path&gt;...                             Path to the installed LLVM
        --llvm-compiler-opts &lt;llvm-compiler-opts&gt;              LLVM compiler opts
        --dart-root &lt;dart-root&gt;
            Path to root of Dart project, otherwise inferred from --dart-output
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从-0-设置-flutterdartrust-环境"><a class="header" href="#从-0-设置-flutterdartrust-环境">从 0 设置 Flutter/Dart+Rust 环境</a></h1>
<blockquote>
<p>This documentation is archived, though technically still correct. Have a look
at <a href="integrate.html">integrating with existing projects</a> chapters for a more
detailed demonstration.</p>
</blockquote>
<p>I suggest that you can start with the
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/with_flutter">Flutter example</a>
first, and modify it to satisfy your needs. It can serve as a template for new
projects. It is run against CI so we are sure it works.</p>
<p>Indeed, this library is nothing but a code generator that helps your
Flutter/Dart functions call Rust functions. Therefore, &quot;how to create a Flutter
app that can run Rust code&quot; is actually out of the scope of this library, and
there are already several tutorials on the Internet.</p>
<p>However, I can sketch the outline of what to do if you want to set up a new
Flutter+Rust project as follows.</p>
<h2 id="step-1"><a class="header" href="#step-1">Step 1</a></h2>
<p>Create a new Flutter project (or use an existing one). The Dart SDK should be
<code>&gt;=2.14.0</code> if you want to use the latest <code>ffigen</code> tool.</p>
<h2 id="step-2"><a class="header" href="#step-2">Step 2</a></h2>
<p>Create a new Rust project, say, at directory <code>rust</code> under the Flutter project.</p>
<h2 id="step-3"><a class="header" href="#step-3">Step 3</a></h2>
<p>Edit <code>Cargo.toml</code> and add:</p>
<pre><code class="language-diff">[lib]
name = &quot;flutter_rust_bridge_example&quot; # whatever you like
# notice this type. `cdylib` for android, and `staticlib` for iOS. I write down a script to change it before build.
+ crate-type = [&quot;cdylib&quot;]
</code></pre>
<h2 id="step-4"><a class="header" href="#step-4">Step 4</a></h2>
<p>Follow the standard steps of &quot;how iOS uses static libraries&quot;.</p>
<ol>
<li>In XCode, edit <code>Strip Style</code> in <code>Build Settings</code> to <code>Debugging Symbols</code>.</li>
<li>Add your <code>lib{crate}.a</code> to <code>Link Binary With Libraries</code> in <code>Build Phases</code>.</li>
<li>Add <code>binding.h</code> to <code>Copy Bundle Resources</code>.</li>
<li>Add <code>#import &quot;binding.h&quot;</code> to <code>Runner-Bridging-Header</code>.</li>
<li>Last but not least, add a never-to-be-executed dummy function in Swift that
calls any of the generated C bindings. This lib has already generated a dummy
method for you, so you simply need to add
<code>print(&quot;dummy_value=\(dummy_method_to_enforce_bundling())&quot;);</code> to swift file's
<code>override func application(...) {}</code>, and this will prevent symbol stripping -
especially in the release build for iOS (i.e. when building ipa file or
releasing to App Store). Notice that, we have to use that
<code>dummy_method_to_enforce_bundling()</code>, otherwise the symbols will not maintain
in the release build, and Flutter will complain it cannot find the symbols.</li>
</ol>
<h2 id="step-5"><a class="header" href="#step-5">Step 5</a></h2>
<p>Lastly, in order to build the Rust library automatically when you are building
Flutter, follow <a href="https://stackoverflow.com/q/69515032/4619958">this tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文章"><a class="header" href="#文章">文章</a></h1>
<p>这一章包含了一些和 <code>flutter_rust_bridge</code> 相关的文章。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-异步"><a class="header" href="#rust-异步">Rust 异步</a></h1>
<blockquote>
<p>作者：@AlienKevin</p>
</blockquote>
<p>This library does not yet support returning a Future type from Rust and this has
to do with the difficulty of uniting the various approaches to async in Rust.
The
<a href="https://rust-lang.github.io/async-book/01_getting_started/03_state_of_async_rust.html#language-and-library-support">Rust Book</a>
summarized the current state of async support succinctly:</p>
<blockquote>
<p>The most fundamental traits, types and functions, such as the Future trait are
provided by the standard library. The async/await syntax is supported directly
by the Rust compiler.</p>
</blockquote>
<blockquote>
<p>Many utility types, macros and functions are provided by the futures crate.
They can be used in any async Rust application.</p>
</blockquote>
<blockquote>
<p>Execution of async code, IO and task spawning are provided by &quot;async
runtimes&quot;, such as Tokio and async-std. Most async applications, and some
async crates, depend on a specific runtime.</p>
</blockquote>
<p>While the futures crate provides an executor called
<code>futures::executor::block_on</code>, libraries that use Tokio runtime cannot use this
executor. According to
<a href="https://runrust.miraheze.org/wiki/Async_crate_comparison">Rust-lang community wiki</a>,
crates like Tokio that provide both a runtime and IO abstractions often have
their IO depend on the runtime. This can make it difficult to write
runtime-agnostic code. First, we demonstrate a common use case of async
programming in Rust by attempting to fetch the content of a file from the
internet using the popular HTTP Client
<a href="https://docs.rs/reqwest/0.11.6/reqwest/">Reqwest</a>:</p>
<pre><code class="language-rust ignore">use anyhow;

async fn get() -&gt; anyhow::Result&lt;String&gt; {
    let url = &quot;https://link/to/file/download&quot;;
    let data = reqwest::get(url).await?.text().await?;
    Ok(data)
}
</code></pre>
<p>When you try to generate bindings for the <code>get</code> function, the generated code
will contain errors because this library does not support returning Future from
Rust.</p>
<h2 id="mismatched-runtime"><a class="header" href="#mismatched-runtime">Mismatched runtime</a></h2>
<p>The next logic thing to try would be to convert the asynchronous code to
synchronous by directly blocking the current thread and execute the code. For
our first attempt, we wrap <code>futures::executor::block_on</code> around an async block
containing reqwest calls.</p>
<pre><code class="language-rust ignore">use anyhow;
use futures::executor::block_on;

fn get() -&gt; anyhow::Result&lt;String&gt; {
    block_on(async {
        let url = &quot;https://link/to/file/download&quot;;
        let data = reqwest::get(url).await?.text().await?;
        Ok(data)
    })
}
</code></pre>
<p>Since Reqwest uses the Tokio runtime instead of the futures runtime, our code
panicked with the error &quot;there is no reactor running, must be called from the
context of a Tokio 1.x runtime&quot;. To fix this error, we have two ways to execute
async codes using the Tokio runtime. Approach 1 is the simplest and uses the
convenient <a href="https://docs.rs/tokio/1.14.0/tokio/attr.main.html"><code>tokio::main</code></a>
macro to turn an async function to a synchronous one. Approach 2 requires you to
explicitly create a new Tokio runtime and use its block_on function to run the
future to completion.</p>
<h2 id="approach-1-macro"><a class="header" href="#approach-1-macro">Approach 1 (macro)</a></h2>
<pre><code class="language-rust ignore">use anyhow;

#[tokio::main(flavor = &quot;current_thread&quot;)]
async fn get() -&gt; anyhow::Result&lt;String&gt; {
    let url = &quot;https://link/to/file/download&quot;;
    let data = reqwest::get(url).await?.text().await?;
    Ok(data)
}
</code></pre>
<p>It has the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
futures = &quot;0.3&quot;
reqwest = &quot;0.11.6&quot;
tokio = { version = &quot;1.14.0&quot;, features = [&quot;rt&quot;, &quot;macros&quot;] }
anyhow = { version = &quot;1.0.49&quot; }
</code></pre>
<h2 id="approach-2-runtime"><a class="header" href="#approach-2-runtime">Approach 2 (runtime)</a></h2>
<pre><code class="language-rust ignore">use anyhow;
use tokio::runtime::Runtime;

fn get() -&gt; anyhow::Result&lt;String&gt; {
    let rt = Runtime::new().unwrap();
    rt.block_on(async {
        let url = &quot;https://link/to/file/download&quot;;
        let data = reqwest::get(url).await?.text().await?;
        Ok(data)
    })
}
</code></pre>
<p>It has the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
futures = &quot;0.3&quot;
reqwest = &quot;0.11.6&quot;
tokio = { version = &quot;1.14.0&quot;, features = [&quot;rt-multi-thread&quot;] }
anyhow = { version = &quot;1.0.49&quot; }
</code></pre>
<h2 id="plain-futures"><a class="header" href="#plain-futures">Plain futures</a></h2>
<p>If you are using the plain futures crate without runtimes like Tokio, you should
be safe to wrap the asynchronous code in an async block and use the
<a href="https://docs.rs/futures/0.3.18/futures/executor/fn.block_on.html"><code>futures::executor::block_on</code></a>
to run the future to completion:</p>
<pre><code class="language-rust ignore">use futures::executor::block_on;

async fn hello_world() -&gt; String {
    &quot;hello, world!&quot;.to_string()
}

fn get() -&gt; String {
    block_on(async {
        hello_world().await
    })
}

fn main() {
    println!(&quot;{}&quot;, get()); // prints &quot;hello, world!&quot;
}
</code></pre>
<h2 id="avoid-async"><a class="header" href="#avoid-async">Avoid async</a></h2>
<p>Lastly, you can avoid async code all together by using synchronously/blocking
version of the functions if they are available. In Reqwest, there's a module
called <code>reqwest::blocking</code> designed specifically for this purpose. So you can
achieve the same thing above without using async.</p>
<pre><code class="language-rust ignore">use anyhow;
use reqwest;

fn get() -&gt; anyhow::Result&lt;String&gt; {
    let url = &quot;https://link/to/file/download&quot;;
    let data = reqwest::blocking::get(url)?.text()?;
    Ok(data)
}
</code></pre>
<p>It has the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
futures = &quot;0.3&quot;
reqwest = { version = &quot;0.11.6&quot;, features = [&quot;blocking&quot;] }
anyhow = { version = &quot;1.0.49&quot; }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-multiple-files"><a class="header" href="#generating-multiple-files">Generating multiple files</a></h1>
<blockquote>
<p>Author: @dbsxdbsx</p>
</blockquote>
<p>This article describes some thoughts and implementations about the feature of generating multiple files.</p>
<p>Before, like the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/rust/src/api.rs">pure_dart's api.rs</a>, all APIs are exposed together in a single file(block). This is not bad when the whole project is simple. But it would become quite hard to maintain or develop, when the project becomes more and more complex, especially when it is a team project. Therefore, it is time to reconstruct code --- classify the exposed Api into proper blocks(files).</p>
<p>(Before going on reading, make sure that you are quite familiar with how to use <a href="https://github.com/Desdaemon/flutter_rust_bridge_template">template</a> to generate code with flutter_rust_bridge. If not, take a look at the former chapters or <a href="https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/frb_example/pure_dart">the basic example</a> again, please.)</p>
<h2 id="try-to-classify-api-into-different-blocksfiles"><a class="header" href="#try-to-classify-api-into-different-blocksfiles">Try to classify Api into different blocks(files)</a></h2>
<p>Suppose, you only have two Api in <code>api.rs</code> originally, like this:</p>
<pre><code class="language-rust noplayground">#![allow(unused_variables)]

pub fn simple_add(a: i32, b: i32) -&gt; i32 {
    a + b
}

pub fn simple_minus(a: i32, b: i32) -&gt; i32 {
    a - b
}
</code></pre>
<p>Now you want to classify these 2 Api into 2 blocks for some reason-- say, you put the <code>simple_add</code> Api into file <code>api_1.rs</code> and the other into <code>api_2.rs</code>. And then make a little modification in <code>lib.rs</code>:</p>
<pre><code class="language-rust noplayground">mod api_1;
mod api_2;
</code></pre>
<p>Ok, now the question is how to deal with them with flutter_rust_bridge? From the <a href="https://github.com/Desdaemon/flutter_rust_bridge_template/blob/main/justfile#L11">template justfile</a>, we know code from a single API file called <code>api_rs</code> can be generated with a command like this:</p>
<pre><code>gen:
    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated.dart&quot; \
...
</code></pre>
<p>(For simplicity, only two necessary flags <code>rust-input</code> and <code>dart-output</code> here.)</p>
<p>Then, to generate code within 2 blocks(files), you may come out with an approach like this:</p>
<pre><code>gen:
    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_1.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_1.dart&quot; \

    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_2.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_2.dart&quot; \
...
</code></pre>
<p>But here comes a problem, how to use them in dart? Like <code>await API.simpleAdd(1,2)</code> or
<code>await API.simpleMinus(1,2)</code> as before? The point here is, to thoroughly decouple Api from different blocks (which is the main reason for using multiple blocks of API), <strong>flag <code>class-name</code> is needed</strong>. So the command should be modified like this:</p>
<pre><code>gen:
    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_1.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_1.dart&quot; \
        --class-name ApiClass1

    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_2.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_2.dart&quot; \
        --class-name ApiClass2
...
</code></pre>
<p>(The class name <code>ApiClass1</code> and <code>ApiClass2</code> are chosen arbitrarily here.)</p>
<p>So now it seems to be perfect to generate code and using Api in Dart like <code>ApiClass1.simpleAdd(1,2)</code> or <code>ApiClass2.simpleMinus(1,2)</code>.</p>
<p>But actually, the above command is still not enough to generate code correctly. Because multiple blocks need to be translated respectively through FFI. So on the rust side, instead of generating code to a single file <a href="https://github.com/Desdaemon/flutter_rust_bridge_template/blob/main/native/src/bridge_generated.rs"><code>bridge_generated.rs</code></a>, now there are 2 files needed. But, what are the names of these 2 auto-generated rust files?
Here, for less misunderstanding, flutter_rust_bridge decides to ask for another compulsory flag <code>rust-output</code>. So the command should be modified like this:</p>
<pre><code>gen:
    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_1.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_1.dart&quot; \
        --class-name ApiClass1 \
        --rust-output generated_api_1

    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_2.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_2.dart&quot; \
        --class-name ApiClass2 \
        --rust-output generated_api_2
...
</code></pre>
<p>(Still, the rust output name <code>generated_api_1</code> and <code>generated_api_2</code> are chosen arbitrarily here.)</p>
<p>That is, flutter_rust_bridge asks you to manually define the generated rust file names, feel free to choose any name you like.</p>
<h2 id="some-issues-with-separate-commands"><a class="header" href="#some-issues-with-separate-commands">Some issues with separate commands</a></h2>
<p>Based on the last commands we come up with, everything seems to be fine --- the code generated, you can use them in Dart, and the whole project is compilable. And you would also notice some changes in <code>lib.rs</code>:</p>
<pre><code class="language-rust noplayground">mod api_1;
mod api_2;
mod generated_api_1; /* AUTO INJECTED BY flutter_rust_bridge. This line may not be accurate, and you can change it according to your needs. */
mod generated_api_2; /* AUTO INJECTED BY flutter_rust_bridge. This line may not be accurate, and you can change it according to your needs. */
</code></pre>
<p>But actually, it is not good enough.</p>
<h3 id="issue-from-explicit-api-conflict"><a class="header" href="#issue-from-explicit-api-conflict">issue from explicit Api conflict</a></h3>
<p>Let's say one day, you decide to add another API, say <code>simpleDivide</code>. But when you compile the whole project, the Dart compiler just complains &quot;The symbol <code>simpleDivide</code> has already been defined ...&quot;. Then you check whether this <code>simpleDivide</code> is defined duplicated. Finally, you find that it's already defined in another block. This situation occurs quite a lot, when the other block is in the charge of someone else, especially in a big project. It is easy to see that the whole routine is a little inefficient since you don't realize the Api conflict until doing compiling when you've probably coded a lot with this &quot;new defined&quot; Api --- and the more time compiling takes, the more inefficient.</p>
<h3 id="issue-from-implicit-api-conflict"><a class="header" href="#issue-from-implicit-api-conflict">issue from implicit Api conflict</a></h3>
<p>And what makes the Api conflict issue more catastrophic? Say you define another Api with parameter <code>String</code> in <code>api_1.rs</code>:</p>
<pre><code class="language-rust noplayground">pub fn test_string_1(s1: String) {
    println!(&quot;test implicit parameter conflicts {}&quot;, s1);
}
</code></pre>
<p>And then you put another Api with parameter <code>String</code> in <code>api_2.rs</code>:</p>
<pre><code class="language-rust noplayground">pub fn test_string_2(s2: String) {
    println!(&quot;test implicit parameter conflicts {}&quot;, s2);
}
</code></pre>
<p>These 2 Apis don't violate the uniqueness required by FFI. They should be compilable with no error. But the truth is no! Why? Because for the <code>String</code> parameter, flutter_rust_bridge would automatically generate API like this:</p>
<pre><code class="language-rust noplayground">#[no_mangle]
pub extern &quot;C&quot; fn new_uint_8_list(len: i32) -&gt; *mut wire_uint_8_list
</code></pre>
<p>which is used to let rust code easily cooperate with Dart through FFI. So if there are 2 APIs both taking <code>String</code> as parameters over blocks, you should notice a similar panic like &quot;the symbol <code>new_uint_8_list</code> is already defined ...&quot; during compiling(<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/511">issue #511</a>).</p>
<p>(Actually, since version <a href="https://github.com/fzyzcjy/flutter_rust_bridge/releases/tag/v1.37.0">1.37</a>, even with the separated commands with no Api defined, the whole project is still not compilable with error &quot;symbol <code>free_WireSyncReturnStruct</code> is already defined... &quot;, the symbol <code>free_WireSyncReturnStruct</code> is another implicitly Api generated by flutter_rust_bridge.)</p>
<p>So these kinds of explicit/implicit Api conflicts are annoying and frustrating. How to resolve it?</p>
<p>Theoretically, the conflict can be detected earlier during generating code, when flutter_rust_bridge knows every detail about API. But the key is that <strong>flutter_rust_bridge has to know all Api over all blocks before generating code</strong>. That is, with the separated command stated above, flutter_rust_bridge can't do the check for you in practice. Therefore, it is necessary to unite the separated commands into ONE command.</p>
<h2 id="correct-command-for-generating-code-with-multiple-blocks"><a class="header" href="#correct-command-for-generating-code-with-multiple-blocks">correct command for generating code with multiple blocks</a></h2>
<p>Now comes the joined command to resolve the above issue:</p>
<pre><code>gen:
    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_1.rs&quot; &quot;$REPO_DIR/native/src/api_2.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_1.dart&quot; &quot;$REPO_DIR/lib/bridge_generated_api_2.dart&quot; \
        --class-name ApiClass1 ApiClass2 \
        --rust-output generated_api_1 generated_api_2
...
</code></pre>
<p>Here, with just 1 command, flutter_rust_bridge would smartly check if there are conflicts over all Api over all blocks, be it defined explicitly or implicitly.</p>
<p>That is, for the explicitly defined APIs like <code>simple_add</code> and <code>simple_minus</code>, if there are duplicated ones, flutter_rust_bridge would throw a panic like &quot;thread 'main' panicked at 'symbol [simple_add] has already been defined'...&quot;, and you are responsible to fix it. And for the implicitly defined API like <code>new_uint_8_list</code>, since it is essential, flutter_rust_bridge would try to work around it by adding suffix starting from 0, like <code>new_uint_8_list_0</code> and <code>new_uint_8_list_1</code>.</p>
<p>To sum up, <strong>there are 4 compulsory flags when you deal with multiple blocks.</strong> They are <code>rust-input</code>, <code>dart-output</code>, <code>class-name</code> and <code>rust-output</code>. Also, the number of fields following each flag should be consistent. You can try to <code>cargo build</code> with fewer flags or inconsistent fields to see what kind of panic would be popped up with the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/frb_example/pure_dart_multi/rust/build.rs">pure_dart_multi</a> example when doing generation.</p>
<h2 id="bizarre-weird-but-compilable-command-with-the-disorder"><a class="header" href="#bizarre-weird-but-compilable-command-with-the-disorder">bizarre, weird but compilable command with the disorder</a></h2>
<p><strong>Flutter_rust_bridge doesn't do semantic correction over all flags.</strong> So, it is syntactically correct with the following generation command:</p>
<pre><code>gen:
    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_orange.rs&quot; &quot;$REPO_DIR/native/src/api_apple.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/gen_api_apple.dart&quot; &quot;$REPO_DIR/lib/gen_api_orange.dart&quot; \
        --class-name ApiClassOrange ApiClassApple \
        --rust-output generated_api_apple generated_api_orange
</code></pre>
<p>NOTE: the suffix <code>apple</code> and <code>orange</code> are quite disordered for each flag here on purpose. It is compilable and usable. But as you should know, it is not a good practice, semantically. It is all up to you to decide the field names for each flag, so be beware of it!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
